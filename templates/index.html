<!DOCTYPE html>
<html lang = "en">
<head>
    <meta charset = "UTF-8">
    <meta name = "viewport" content = "width = device-width, initial-scale = 1.0">
    <title>World of the Wand - Tome of Echoes</title>
    <link rel = "stylesheet" href = "{{url_for('game.static', filename = 'style.css')}}">

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
        // Path must exactly match the server-side path for Socket.IO
        const socket = io({path: "/world-of-the-wand/socket.io"});
    </script>
</head>
<body>
    <div class="main-ui-container">
        <div class="left-panel">
            <div id="commandLog"></div>
        </div>

        <div class="right-panel">
            <div id="mainHeaderStatusContainer">
                <div id="debugMenu">
                    <label>
                        <input type="checkbox" id="debugInfoToggle"> Debug Info
                    </label>
                    <label>
                        <input type="checkbox" id="localCommandsToggle" checked> Local Commands
                    </label>
                    <div id="rainIntensityControl">
                        <label>
                            Rain Intensity: <input type="range" id="rainIntensitySlider" min="0" max="1" step="0.05">
                        </label>
                    </div>
                </div>
                <div id="mainHeaderStatus">Welcome to the World of the Wand!</div>
            </div>

            <div id="gameCanvasContainer">
                <div id="gameCanvas">Initializing Realm...</div>
                <div id="rainOverlay"></div>
            </div>
            
            <div id="commandInputBox">
                <form id="commandForm">
                    <label for="commandText">
                        <span id="tickIndicator">●</span>Inscribe Thy Will:
                    </label>
                    <div id="commandText" contenteditable="true" spellcheck="false" autocomplete="off" role="textbox" aria-multiline="false"></div>
                    <button type="submit">Commit</button>
                </form>
            </div>
        </div>
    </div>

    <script>
        const gameCanvas = document.getElementById('gameCanvas');
        const gameCanvasContainer = document.getElementById('gameCanvasContainer');
        const rainOverlay = document.getElementById('rainOverlay');
        const mainHeaderStatus = document.getElementById('mainHeaderStatus');
        const commandLog = document.getElementById('commandLog');
        const commandForm = document.getElementById('commandForm');
        const commandInput = document.getElementById('commandText');
        const tickIndicator = document.getElementById('tickIndicator');
        const debugInfoToggle = document.getElementById('debugInfoToggle');
        const localCommandsToggle = document.getElementById('localCommandsToggle');
        const rainIntensitySlider = document.getElementById('rainIntensitySlider');
        const rainIntensityControl = document.getElementById('rainIntensityControl');

        let showDebugInfo = false; 
        let useLocalCommands = true;
        
        let selfPlayer = null;
        let otherPlayers = {};
        let myPlayerID = null;
        let GRID_WIDTH = 20; 
        let GRID_HEIGHT = 15;
        let GAME_TICK_RATE = 0.75;
        let OBSERVABLE_DEPTH = 17;
        let prevSelfPlayerState = null;

        let currentSceneData = {
            InsideID: 0, 
            name: "The Whispering Plains" 
        };
        let globalWeather = {
            isRaining: true, 
            intensity: 0.1 
        };
        let rainInterval = null;
        const RAIN_INTERVAL_DELAY = 50; 

        let isDragging = false;
        let startDragX, startDragY;
        let currentPanX = 0, currentPanY = 0; 
        let targetPanX = 0, targetPanY = 0;   

        let charRenderWidth = 10; 
        let charRenderHeight = 16; 
        let charSizeEstimated = false;


        const FOG_CHAR = '░'; 
        const FLOOR_CHAR = '·'; 
        const AURA_VISION_RANGE = 1;

        function get_dx_dy_from_direction_str(s) {
            const mapping = {'^': [0, -1], 'v': [0, 1], '<': [-1, 0], '>': [1, 0]};
            return mapping[s] || [0, 0];
        }

        function get_direction_str_from_dx_dy(dx, dy) {
            const mapping = {"0,-1": '^', "0,1": 'v', "-1,0": '<', "1,0": '>'};
            return mapping[`${dx},${dy}`];
        }

        function getRelativeCoords(playerX, playerY, playerFacingChar, targetX, targetY) {
            const worldDX = targetX - playerX;
            const worldDY = targetY - playerY;
            let pf;
            if (playerFacingChar === '^') pf = 'n';
            else if (playerFacingChar === 'v') pf = 's';
            else if (playerFacingChar === '<') pf = 'w';
            else if (playerFacingChar === '>') pf = 'e';
            else return { rx: worldDX, ry: worldDY };

            if (pf === 'n') return {rx: worldDX, ry: worldDY};
            if (pf === 's') return {rx: -worldDX, ry: -worldDY};
            if (pf === 'w') return {rx: -worldDY, ry: worldDX};
            if (pf === 'e') return {rx: worldDY, ry: -worldDX};
            return { rx: worldDX, ry: worldDY };
        }

        function manhattanDistance(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) + Math.abs(y1 - y2);
        }

        function isVisible(observerX, observerY, observerChar, targetX, targetY, scry = false) {
            if (!observerChar) return false;
            let manhattanDist = manhattanDistance(observerX, observerY, targetX, targetY);

            if (scry || manhattanDist <= AURA_VISION_RANGE) {
                return true;
            }
            
            const {rx, ry} = getRelativeCoords(observerX, observerY, observerChar, targetX, targetY);
            const OBSERVABLE_WIDTH_CONST = 1.0;

            if (ry < 0 && -ry <= OBSERVABLE_DEPTH && Math.abs(rx) <= Math.floor(-ry * OBSERVABLE_WIDTH_CONST )) {
                return true;
            }
            return false;
        }


        function addLogMessage(message, type = 'lore') {
            const logEntry = document.createElement('div');
            let displayStyle = 'ink';
            switch (type) {
                case 'event-bad':         
                case 'chat-shout':       
                case 'server-major-event': 
                case 'player-trade':       
                case 'player-damage':
                case 'welcome-message': 
                    displayStyle = 'mana';
                    break;
                case 'system':            
                case 'event-good':        
                case 'spell-cast':        
                case 'lore':              
                case 'user-input':        
                case 'chat-say':          
                default:
                    displayStyle = 'ink';
                    break;
            }
            logEntry.classList.add('log-entry', `log-style-${displayStyle}`, `log-type-${type}`);
            logEntry.textContent = message;
            commandLog.appendChild(logEntry);
            requestAnimationFrame(() => { commandLog.scrollTop = commandLog.scrollHeight; });
        }

        function updateStatus(statusText) {
            if (statusText) {
                mainHeaderStatus.textContent = statusText;
            } else if (selfPlayer) {
                let healthPercentage = selfPlayer.max_health > 0 ? Math.round((selfPlayer.current_health / selfPlayer.max_health) * 100) : 0;
                let baseStatus = `Health: ${healthPercentage}% | Mana: ${selfPlayer.current_mana}/${selfPlayer.max_mana} | Gold: ${selfPlayer.gold || 0} | Potions: ${selfPlayer.potions}`;
                if (showDebugInfo) {
                    let locationType = currentSceneData.InsideID === 0 ? 'Outdoors' : `Indoors (ID:${currentSceneData.InsideID})`;
                     baseStatus = `Scene: (${selfPlayer.scene_x},${selfPlayer.scene_y}) ${currentSceneData.name} [${locationType}] | ${selfPlayer.char}:(${selfPlayer.x},${selfPlayer.y}) | ${baseStatus}`;
                }
                mainHeaderStatus.textContent = baseStatus;
            } else {
                mainHeaderStatus.textContent = "Connecting to the World of the Wand...";
            }
        }

        function estimateCharacterSize() {
            if (charSizeEstimated || !gameCanvas.textContent || gameCanvas.textContent.startsWith("Initializing Realm...") || gameCanvas.textContent.startsWith("The mists")) {
                 if (!charSizeEstimated) { 
                    const computedStyle = getComputedStyle(gameCanvas);
                    const fontSizeStr = computedStyle.fontSize || "18px";
                    const lineHeightStr = computedStyle.lineHeight; // CSS sets this to 0.9

                    charRenderWidth = parseFloat(fontSizeStr) * 0.6; // Approximation

                    let fs = parseFloat(fontSizeStr);
                    if (lineHeightStr === 'normal') {
                        charRenderHeight = fs * 1.2; // Common fallback for 'normal'
                    } else {
                        charRenderHeight = fs * parseFloat(lineHeightStr);
                    }
                    console.warn("Using early fallback char size for initial centering:", charRenderWidth, charRenderHeight);
                    charSizeEstimated = true; // Mark as estimated to avoid re-entry before font-ready measure
                 }
                return;
            }
            
            const tempSpan = document.createElement('span');
            tempSpan.style.fontFamily = getComputedStyle(gameCanvas).fontFamily;
            tempSpan.style.fontSize = getComputedStyle(gameCanvas).fontSize;
            tempSpan.style.lineHeight = getComputedStyle(gameCanvas).lineHeight;
            tempSpan.style.whiteSpace = 'pre';
            tempSpan.style.visibility = 'hidden';
            tempSpan.style.position = 'absolute'; 
            tempSpan.textContent = 'M'; // A common character for width, though for height, box is more important
            document.body.appendChild(tempSpan);
            
            charRenderWidth = tempSpan.offsetWidth;
            const lh = parseFloat(getComputedStyle(gameCanvas).lineHeight); // Should be 0.9 from CSS
            const fs = parseFloat(getComputedStyle(gameCanvas).fontSize);
            charRenderHeight = fs * lh; 
            
            document.body.removeChild(tempSpan);

            if (charRenderWidth > 0 && charRenderHeight > 0) {
                charSizeEstimated = true;
                console.log("Estimated char size via tempSpan (W x H):", charRenderWidth, "x", charRenderHeight);
            } else { 
                // Fallback if tempSpan measurement failed (e.g., offsetWidth was 0)
                const computedStyle = getComputedStyle(gameCanvas);
                const fontSizeStr = computedStyle.fontSize || "18px";
                const lineHeightStr = computedStyle.lineHeight;

                charRenderWidth = parseFloat(fontSizeStr) * 0.6; 
                let fsVal = parseFloat(fontSizeStr);
                if (lineHeightStr === 'normal') {
                    charRenderHeight = fsVal * 1.2; 
                } else {
                    charRenderHeight = fsVal * parseFloat(lineHeightStr);
                }
                console.warn("Failed to estimate char size accurately via tempSpan, using computed fallback:", charRenderWidth, charRenderHeight);
                charSizeEstimated = true; 
            }
        }


        function drawGrid() {
            if (!selfPlayer || GRID_WIDTH === 0 || GRID_HEIGHT === 0) {
                gameCanvas.textContent = "The mists obscure your vision...\n\n(Awaiting server data)";
                gameCanvas.style.transform = `translate(0px, 0px)`; 
                return;
            }
            gameCanvas.style.transform = `translate(${currentPanX}px, ${currentPanY}px)`;

            let displayGrid = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(FLOOR_CHAR));
            
            for (const playerID in otherPlayers) {
                const otherGuy = otherPlayers[playerID];
                if (otherGuy.scene_x === selfPlayer.scene_x && otherGuy.scene_y === selfPlayer.scene_y) {
                    if (otherGuy.x >= 0 && otherGuy.x < GRID_WIDTH && otherGuy.y >= 0 && otherGuy.y < GRID_HEIGHT) {
                        displayGrid[otherGuy.y][otherGuy.x] = otherGuy.char;
                    }
                }
            }
            if (selfPlayer.x >= 0 && selfPlayer.x < GRID_WIDTH && selfPlayer.y >= 0 && selfPlayer.y < GRID_HEIGHT) {
                displayGrid[selfPlayer.y][selfPlayer.x] = selfPlayer.char;
            }

            let output = "";
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (isVisible(selfPlayer.x, selfPlayer.y, selfPlayer.char, x, y)) {
                        output += displayGrid[y][x];
                    } else {
                        output += FOG_CHAR;
                    }
                }
                output += "\n";
            }
            gameCanvas.textContent = output.trimEnd();
        }
        
        function startRainEffect(intensity) {
            if (rainInterval) clearInterval(rainInterval);
            rainOverlay.innerHTML = ''; 

            rainInterval = setInterval(() => {
                if (Math.random() < (intensity * 0.5) ) { 
                    const drop = document.createElement('div');
                    drop.classList.add('raindrop');
                    drop.style.left = Math.random() * 100 + '%';
                    
                    const duration = 0.4 + Math.random() * 0.4; 
                    drop.style.animationDuration = duration + 's';
                    drop.style.animationDelay = Math.random() * 0.2 + 's'; 
                    
                    rainOverlay.appendChild(drop);

                    drop.addEventListener('animationend', () => {
                        drop.remove();
                    });
                }
            }, RAIN_INTERVAL_DELAY);
        }

        function stopRainEffect() {
            if (rainInterval) clearInterval(rainInterval);
            rainInterval = null;
            rainOverlay.innerHTML = ''; // Clear any remaining drops
        }
        
        function updateWeatherEffects() {
            if (globalWeather.isRaining && currentSceneData.InsideID === 0) {
                // Check if intensity actually changed or if rain needs to start
                if (!rainInterval || rainIntensitySlider.valueAsNumber !== globalWeather.intensity) {
                    globalWeather.intensity = rainIntensitySlider.valueAsNumber; // Sync with slider
                    startRainEffect(globalWeather.intensity);
                }
            } else {
                if (rainInterval) stopRainEffect();
            }
        }

        gameCanvasContainer.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return; // Only left click
            isDragging = true;
            document.body.classList.add('is-dragging');
            gameCanvasContainer.style.cursor = 'grabbing';
            startDragX = e.clientX - currentPanX;
            startDragY = e.clientY - currentPanY;
            gameCanvas.style.transition = 'none'; // Allow instant drag
        });

        window.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            currentPanX = e.clientX - startDragX;
            currentPanY = e.clientY - startDragY;
            gameCanvas.style.transform = `translate(${currentPanX}px, ${currentPanY}px)`;
        });

        window.addEventListener('mouseup', (e) => {
            if (e.button !== 0 || !isDragging) return;
            isDragging = false;
            document.body.classList.remove('is-dragging');
            gameCanvasContainer.style.cursor = 'grab';
            gameCanvas.style.transition = 'transform 0.3s ease-out'; // Smooth transition for recentering or if needed
            // No automatic recenter on mouseup; let user control view unless an action forces it
        });
        gameCanvasContainer.addEventListener('mouseleave', () => {
            if(isDragging){ // If mouse leaves container while dragging, treat as drag end
                isDragging = false;
                document.body.classList.remove('is-dragging');
                gameCanvasContainer.style.cursor = 'grab';
                gameCanvas.style.transition = 'transform 0.3s ease-out';
            }
        });

        function centerViewOnPlayer() {
            if (!selfPlayer || !charSizeEstimated || GRID_WIDTH === 0 || GRID_HEIGHT === 0 || !gameCanvasContainer || !gameCanvas) {
                 console.warn("Cannot center view: missing player, char size, or canvas elements.");
                 currentPanX = 0;
                 currentPanY = 0;
                 if(gameCanvas) gameCanvas.style.transform = `translate(${currentPanX}px, ${currentPanY}px)`;
                return; 
            }
            
            // Calculate the player's character's visual center point within the gameCanvas's own coordinate system
            const playerVisualCenterX = (selfPlayer.x * charRenderWidth) + (charRenderWidth / 2);
            const playerVisualCenterY = (selfPlayer.y * charRenderHeight) + (charRenderHeight / 2);

            // Calculate the translation needed to bring that point to the center of the gameCanvasContainer
            targetPanX = (gameCanvasContainer.clientWidth / 2) - playerVisualCenterX;
            targetPanY = (gameCanvasContainer.clientHeight / 2) - playerVisualCenterY;
            
            // Apply the translation
            currentPanX = targetPanX;
            currentPanY = targetPanY;
            // console.log(`Centering: Player(${selfPlayer.x},${selfPlayer.y}), CharSize(${charRenderWidth.toFixed(2)},${charRenderHeight.toFixed(2)}), PlayerVisual(${playerVisualCenterX.toFixed(2)},${playerVisualCenterY.toFixed(2)}), Container(${gameCanvasContainer.clientWidth},${gameCanvasContainer.clientHeight}), TargetPan(${targetPanX.toFixed(2)},${targetPanY.toFixed(2)})`);
            gameCanvas.style.transform = `translate(${currentPanX}px, ${currentPanY}px)`;
        }


        debugInfoToggle.addEventListener('change', (event) => {
            showDebugInfo = event.target.checked;
            localStorage.setItem('showDebugInfo', JSON.stringify(showDebugInfo)); 
            rainIntensityControl.style.display = showDebugInfo ? 'block' : 'none';
            updateStatus(); 
        });
        localCommandsToggle.addEventListener('change', (event) => {
            useLocalCommands = event.target.checked;
            localStorage.setItem('useLocalCommands', JSON.stringify(useLocalCommands));
        });
        rainIntensitySlider.addEventListener('input', (event) => {
            const newIntensity = parseFloat(event.target.value);
            if (globalWeather.intensity !== newIntensity) {
                globalWeather.intensity = newIntensity;
                localStorage.setItem('rainIntensity', globalWeather.intensity.toString());
                if (globalWeather.isRaining && currentSceneData.InsideID === 0) {
                    startRainEffect(globalWeather.intensity); 
                }
            }
        });

        // --- Socket.IO Event Handlers ---
        socket.on('connect', () => {
            console.log("Socket.IO connected successfully! SID:", socket.id);
            myPlayerID = socket.id; // Set myPlayerID upon successful connection
            addLogMessage("Tome hums: Connection to the Ethereal Plane established.", 'system');
            // Initial state will be sent by server, no need to request here
        });

        socket.on('connect_error', (err) => {
            console.error("Socket.IO connection error:", err);
            addLogMessage(`Tome screams: Connection Error! ${err.message} (Type: ${err.type}, Description: ${err.description})`, 'event-bad');
            updateStatus("Connection failed. Trying to reconnect...");
        });

        socket.on('initial_state', (data) => {
            console.log("Received initial_state:", data);
            if (!data || !data.player) {
                console.error("Received invalid initial_state data:", data);
                addLogMessage("Tome flickers: Received corrupted manifestation data from the server.", 'event-bad');
                return;
            }
            selfPlayer = data.player; 
            // myPlayerID is already set from socket.id on 'connect' event, but we can verify
            if (selfPlayer.id !== myPlayerID) {
                console.warn(`Player ID mismatch! Socket ID: ${myPlayerID}, Server assigned ID: ${selfPlayer.id}. Using server ID.`);
                myPlayerID = selfPlayer.id;
            }

            GRID_WIDTH = data.grid_width; 
            GRID_HEIGHT = data.grid_height;
            GAME_TICK_RATE = data.tick_rate;
            otherPlayers = data.other_players || {}; // Ensure otherPlayers is an object
            prevSelfPlayerState = { ...selfPlayer };

            // Load preferences
            const savedDebugInfo = localStorage.getItem('showDebugInfo');
            showDebugInfo = savedDebugInfo !== null ? JSON.parse(savedDebugInfo) : false;
            debugInfoToggle.checked = showDebugInfo; 
            rainIntensityControl.style.display = showDebugInfo ? 'block' : 'none';

            const savedLocalCommands = localStorage.getItem('useLocalCommands');
            useLocalCommands = savedLocalCommands !== null ? JSON.parse(savedLocalCommands) : true;
            localCommandsToggle.checked = useLocalCommands;

            const savedRainIntensity = localStorage.getItem('rainIntensity');
            globalWeather.intensity = savedRainIntensity !== null ? parseFloat(savedRainIntensity) : 0.1;
            rainIntensitySlider.value = globalWeather.intensity;

            if (otherPlayers[myPlayerID]) delete otherPlayers[myPlayerID]; // Should not happen if server sends correctly

            // UI setup, dependent on fonts being ready for char size estimation
            document.fonts.ready.then(() => {
                console.log("Fonts ready, proceeding with initial UI setup after initial_state.");
                if (selfPlayer && typeof GRID_WIDTH === 'number' && GRID_WIDTH > 0) {
                    estimateCharacterSize(); // Estimate first
                    drawGrid(); // Then draw
                    updateStatus(); 
                    centerViewOnPlayer(); // Then center
                    updateWeatherEffects(); 
                    addLogMessage(`Tome: You have materialized in The Whispering Plains. Your journey begins. (SID: ${myPlayerID})`, 'welcome-message');
                    if (currentSceneData.InsideID === 0 && globalWeather.isRaining) {
                        addLogMessage("Tome notes: A chilling rain falls from the slate-grey sky.", 'system');
                    }
                } else {
                    gameCanvas.textContent = "Error: Could not initialize player or world data correctly."; 
                    addLogMessage("Tome warns: Error! Could not manifest in world due to corrupted data.", 'event-bad');
                    console.error("Critical data missing for UI setup:", selfPlayer, GRID_WIDTH);
                }
            }).catch(err => {
                console.error("Font loading error or timeout:", err);
                addLogMessage("Tome sighs: Font sorcery failed. Visuals may be askew.", 'event-bad');
                // Attempt to setup UI anyway, might use fallback char sizes
                if (selfPlayer && typeof GRID_WIDTH === 'number' && GRID_WIDTH > 0) {
                    estimateCharacterSize(); drawGrid(); updateStatus(); centerViewOnPlayer(); updateWeatherEffects();
                }
            });
        });

        socket.on('player_joined', (newPlayerData) => { 
            console.log("Player joined:", newPlayerData);
            if (myPlayerID && newPlayerData.id !== myPlayerID && selfPlayer &&
                newPlayerData.scene_x === selfPlayer.scene_x && newPlayerData.scene_y === selfPlayer.scene_y) {
                otherPlayers[newPlayerData.id] = newPlayerData; 
                drawGrid();
                addLogMessage(`Tome notes: ${newPlayerData.name || 'A new sorcerer'} arrives in this area.`, 'event-good');
            }
        });

        socket.on('player_left', (data) => { // Expecting {id: playerID_left}
            const playerID = data.id;
            console.log("Player left:", playerID);
            if (otherPlayers[playerID]) {
                const leftPlayerName = otherPlayers[playerID].name || 'A sorcerer';
                delete otherPlayers[playerID];
                drawGrid();
                addLogMessage(`Tome records: ${leftPlayerName} has departed this area.`, 'lore');
            }
        });

        socket.on('lore_message', (data) => {
            addLogMessage(data.message, data.type || 'lore');
        });

        socket.on('weather_update', (weatherData) => {
            const wasRaining = globalWeather.isRaining;
            globalWeather = weatherData; 
            rainIntensitySlider.value = globalWeather.intensity; 
            updateWeatherEffects();
            if (currentSceneData.InsideID === 0) { 
                if (globalWeather.isRaining && !wasRaining) {
                    addLogMessage("Tome scribes: The heavens open, and rain begins to pour.", 'system');
                } else if (!globalWeather.isRaining && wasRaining) {
                    addLogMessage("Tome notes: The rain lessens and finally stops.", 'system');
                }
            }
        });

        socket.on('scene_data_update', (sceneData) => {
            currentSceneData = sceneData;
            updateStatus(); 
            updateWeatherEffects(); 
            addLogMessage(`Tome turns a page: You find yourself in ${currentSceneData.name}.`, 'lore');
        });

        socket.on('chat_message', (data) => {
            let prefix = "";
            let messageType = 'chat-say'; 
            if (data.type === 'shout') {
                prefix = `[SHOUT from ${data.sender_name || 'A distant voice'} at ${data.scene_coords || '(unknown location)'}]: `;
                messageType = 'chat-shout';
            } else { 
                prefix = `[${data.sender_name || 'Someone nearby'} says]: `;
                messageType = 'chat-say'; 
            }
            addLogMessage(prefix + data.message, messageType);
        });

        let tickFlashTimeout = null;
        socket.on('game_state_update', (allPlayers) => {
            // This log can be very noisy, consider enabling only for deep debugging
            // console.log("Client received game_state_update with", allPlayers ? allPlayers.length : 0, "player states."); 
            if (!selfPlayer || !myPlayerID) {
                console.warn("Received game_state_update but selfPlayer or myPlayerID is not set. Ignoring.");
                return;
            }
            
            if(tickIndicator) {
                tickIndicator.classList.add('tick-flash');
                if(tickFlashTimeout) clearTimeout(tickFlashTimeout);
                tickFlashTimeout = setTimeout(() => {
                    if(tickIndicator) tickIndicator.classList.remove('tick-flash');
                }, 150); 
            }

            let foundSelf = false;
            const currentOtherPlayersInMyScene = {};
            
            for (const playerData of allPlayers) {
                if (playerData.id === myPlayerID) {
                    selfPlayer = playerData; 
                    foundSelf = true;
                } else if (playerData.scene_x === selfPlayer.scene_x && playerData.scene_y === selfPlayer.scene_y) {
                    // Only track other players if selfPlayer is defined (which it should be if foundSelf becomes true)
                    currentOtherPlayersInMyScene[playerData.id] = playerData;
                }
            }
            otherPlayers = currentOtherPlayersInMyScene;

            if (!foundSelf) {
                // This is a problematic state - server sent an update that doesn't include us
                updateStatus("Your connection to this world wavers... (Desynchronized)");
                addLogMessage("Tome's script flickers: Warning! Your essence is not found in the latest planar update.", 'event-bad');
            } else { 
                 updateStatus(); 
            }

            if (selfPlayer && prevSelfPlayerState) {
                const sceneCoordsChanged = selfPlayer.scene_x !== prevSelfPlayerState.scene_x || selfPlayer.scene_y !== prevSelfPlayerState.scene_y;
                if (sceneCoordsChanged) {
                    // Repopulate otherPlayers based on the new scene
                    otherPlayers = {}; 
                    for (const playerData of allPlayers) { // Re-iterate allPlayers as selfPlayer's scene might have changed
                        if (playerData.id !== myPlayerID && playerData.scene_x === selfPlayer.scene_x && playerData.scene_y === selfPlayer.scene_y) {
                            otherPlayers[playerData.id] = playerData;
                        }
                    }
                    if(!isDragging) requestAnimationFrame(centerViewOnPlayer); 
                } else { 
                    const movedX = selfPlayer.x !== prevSelfPlayerState.x;
                    const movedY = selfPlayer.y !== prevSelfPlayerState.y;
                    const turned = selfPlayer.char !== prevSelfPlayerState.char;

                    if (movedX || movedY) {
                        // Message for local move is handled by command parser if useLocalCommands is true
                        // This message is for server-confirmed moves
                        if (!useLocalCommands) { 
                            let facingDirectionWord = getDirectionWord(selfPlayer.char);
                            addLogMessage(`Tome traces your path: You move within scene (${selfPlayer.scene_x},${selfPlayer.scene_y}) to (${selfPlayer.x}, ${selfPlayer.y}), facing ${facingDirectionWord}.`, 'lore');
                        }
                        if (!isDragging) requestAnimationFrame(centerViewOnPlayer); 
                    } else if (turned) {
                         if (!useLocalCommands) {
                            let facingDirectionWord = getDirectionWord(selfPlayer.char);
                            addLogMessage(`Tome observes: You turn to face ${facingDirectionWord} at (${selfPlayer.x},${selfPlayer.y}) in scene (${selfPlayer.scene_x},${selfPlayer.scene_y}).`, 'lore');
                        }
                         if (!isDragging) requestAnimationFrame(centerViewOnPlayer); 
                    }
                }
            }
            if (selfPlayer) prevSelfPlayerState = { ...selfPlayer }; // Deep copy for next comparison
            
            drawGrid(); 
            if (!charSizeEstimated && selfPlayer && gameCanvas.textContent && !gameCanvas.textContent.startsWith("The mists") && !gameCanvas.textContent.startsWith("Initializing Realm...")) {
                // This might be redundant if document.fonts.ready handles initial estimation well
                console.log("Attempting char size estimation post game_state_update due to !charSizeEstimated");
                requestAnimationFrame(() => { 
                    estimateCharacterSize();
                    if(!isDragging) centerViewOnPlayer(); 
                });
            }
            updateWeatherEffects(); 
        });

        function getDirectionWord(char) {
            if (char === '^') return "North"; if (char === 'v') return "South";
            if (char === '<') return "West";  if (char === '>') return "East";
            return "an unknown direction";
        }
        socket.on('action_queued', (data) => { addLogMessage("Tome confirms: " + data.message, "system");});
        socket.on('action_failed', (data) => { addLogMessage("Tome shakes its pages: " + data.message, 'event-bad'); });
        
        socket.on('disconnect', (reason) => { 
            console.log("Socket.IO disconnected. Reason:", reason);
            updateStatus(`Severed from the Ethereal Plane! (${reason})`);
            addLogMessage(`Tome wails: Disconnected! Reason: ${reason}. The weave unravels!`, 'event-bad');
            selfPlayer = null; otherPlayers = {}; prevSelfPlayerState = null;
            stopRainEffect(); 
            drawGrid(); // Will show "Mists obscure..."
        });

        const ACTION_ALIASES = {
            "move": ["move", "go", "walk", "step", "head", "run"],
            "look": ["look", "face", "turn"],
            "cast": ["cast", "zap", "fire", "spell"],
            "drink": ["drink", "quaff", "use"],
            "say": ["say", "tell", "whisper", "'"], 
            "shout": ["shout", "yell", "scream", "!"], 
            "help": ["help", "?"]
        };
        const DIRECTION_ALIASES = {
            "north":    {char: '^', dx: 0,  dy: -1, aliases: ["north", "n", "up"]},
            "south":    {char: 'v', dx: 0,  dy: 1,  aliases: ["south", "s", "down"]},
            "west":     {char: '<', dx: -1, dy: 0,  aliases: ["west", "w", "left", "lft", "l"]},
            "east":     {char: '>', dx: 1,  dy: 0,  aliases: ["east", "e", "right", "rght", "rgt", "r"]},
            "forward":  {relative: true, aliases: ["forward", "forwards", "fwd", "f", "ahead", "straight", "onward", "onwards"]},
            "backward": {relative: true, aliases: ["backward", "backwards", "back", "bck", "behind", "b"]},
        };
        function parseAction(actionWord) {
            actionWord = actionWord.toLowerCase();
            for (const canonicalAction in ACTION_ALIASES) {
                if (ACTION_ALIASES[canonicalAction].includes(actionWord)) return canonicalAction;
            }
            return null;
        }
        function parseDirection(directionStr, curFacing) {
            directionStr = directionStr.toLowerCase();
            let result = {char: curFacing, dx: 0, dy: 0, isValid: false}; // Default to no change if invalid
            for (const dirKey in DIRECTION_ALIASES) {
                const config = DIRECTION_ALIASES[dirKey];
                if (config.aliases.includes(directionStr)) {
                    if (config.relative) {
                        result.isValid = true;
                        const [currentDx, currentDy] = get_dx_dy_from_direction_str(curFacing);
                        if (currentDx === 0 && currentDy === 0 && !['^','v','<','>'].includes(curFacing)) { // Player not facing a valid direction
                            result.isValid = false; // Cannot move relative if not facing a cardinal direction
                            break;
                        }
                        if (dirKey === "forward") {
                            result.char = curFacing;
                            result.dx = currentDx; result.dy = currentDy;
                        } else if (dirKey === "backward") {
                            // Turn 180 degrees and set dx/dy for one step in that new direction
                            if      (curFacing === '^') result = {char: 'v', dx: 0,  dy: 1,  isValid: true};
                            else if (curFacing === 'v') result = {char: '^', dx: 0,  dy: -1, isValid: true};
                            else if (curFacing === '<') result = {char: '>', dx: 1,  dy: 0,  isValid: true};
                            else if (curFacing === '>') result = {char: '<', dx: -1, dy: 0,  isValid: true};
                            else result.isValid = false; // Should not happen if initial check passed
                        }
                    } else { // Absolute direction
                        result = {char: config.char, dx: config.dx, dy: config.dy, isValid: true};
                    }
                    return result;
                }
            }
            return result; // Returns with isValid: false if no match
        }

        commandInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                if (typeof commandForm.requestSubmit === 'function') {
                    commandForm.requestSubmit();
                } else { 
                    const submitButton = commandForm.querySelector('button[type="submit"]');
                    if (submitButton) submitButton.click();
                }
            }
        });

        commandForm.addEventListener('submit', (event) => {
            event.preventDefault();
            if (!selfPlayer) {
                addLogMessage("Tome whispers urgently: You are not fully manifest in this realm yet!", 'event-bad');
                return;
            }
            const inputText = commandInput.textContent.trim();
            commandInput.innerHTML = ''; // Clear input

            if (!inputText) return;
            
            const parts = inputText.split(/\s+/);
            let actionWord = parts[0];
            let messageContent = parts.length > 1 ? parts.slice(1).join(' ') : null;

            // Handle chat shortcuts ' and !
            if (actionWord.startsWith("'") && actionWord.length > 1) { // 'say something
                messageContent = (actionWord.substring(1) + (messageContent ? " " + messageContent : "")).trim();
                actionWord = "say";
            } else if (actionWord.startsWith("!") && actionWord.length > 1) { // !shout something
                 messageContent = (actionWord.substring(1) + (messageContent ? " " + messageContent : "")).trim();
                actionWord = "shout";
            }


            addLogMessage(`Tome jots down: ${actionWord}${messageContent ? ' ' + messageContent : ''}`, 'user-input');

            const canonicalAction = parseAction(actionWord);

            if (!canonicalAction) {
                addLogMessage(`Tome seems puzzled: Your will "${actionWord}" is indecipherable. (Perhaps 'help' will illuminate the path?)`, 'event-bad');
                commandInput.focus(); return;
            }

            let commandToSend = { type: canonicalAction, details: {} };
            let shouldEmit = true; 

            if (useLocalCommands && (canonicalAction === "move" || canonicalAction === "look")) {
                shouldEmit = false; // Process locally, do not send to server
                const effectiveTargetWord = messageContent || (canonicalAction === "move" ? "forward" : selfPlayer.char); // Look defaults to current facing if no direction given
                const dirResult = parseDirection(effectiveTargetWord, selfPlayer.char);

                if (dirResult.isValid) {
                    let newX = selfPlayer.x;
                    let newY = selfPlayer.y;

                    if (canonicalAction === "move") {
                        newX += dirResult.dx;
                        newY += dirResult.dy;
                        
                        // Boundary checks (local move does not transition scenes)
                        newX = Math.max(0, Math.min(GRID_WIDTH - 1, newX));
                        newY = Math.max(0, Math.min(GRID_HEIGHT - 1, newY));
                    }
                    
                    selfPlayer.x = newX;
                    selfPlayer.y = newY;
                    selfPlayer.char = dirResult.char; // Update facing direction
                    
                    addLogMessage(`Tome (Local): You ${canonicalAction} ${getDirectionWord(dirResult.char)}.`, 'system');
                    drawGrid();
                    if (!isDragging) requestAnimationFrame(centerViewOnPlayer);
                    updateStatus();
                } else {
                    addLogMessage(`Tome frowns (Local): Your path to "${effectiveTargetWord}" is unclear.`, 'event-bad');
                }
            } else if (canonicalAction === "move") { 
                const effectiveTargetWord = messageContent || "forward"; // Default to "forward" if no direction given
                const dirResult = parseDirection(effectiveTargetWord, selfPlayer.char);
                if (dirResult.isValid) {
                    commandToSend.details = { dx: dirResult.dx, dy: dirResult.dy, newChar: dirResult.char };
                } else { 
                    addLogMessage(`Tome frowns: You ponder moving towards "${effectiveTargetWord}", but the way is unclear.`, 'event-bad');
                    shouldEmit = false;
                }
            } else if (canonicalAction === "look") { 
                const effectiveTargetWord = messageContent || selfPlayer.char; // Default to current facing if no direction given for look
                const dirResult = parseDirection(effectiveTargetWord, selfPlayer.char);
                if (dirResult.isValid) {
                    commandToSend.details = { dx: 0, dy: 0, newChar: dirResult.char }; // Look only changes char, no dx/dy for server movement
                    // Server will handle any log messages for server-side look
                } else { 
                    addLogMessage(`Tome squints: You try to peer towards "${effectiveTargetWord}", but your vision blurs.`, 'event-bad');
                    shouldEmit = false;
                }
            } else if (canonicalAction === "help") { 
                addLogMessage("Tome patiently explains:\nTo MOVE, try: 'move north', 'go w', 'run forward', etc.\nTo LOOK: 'look east', 'face s', 'turn backward'.\nTo CAST: 'cast [spell name] [direction if applicable]'.\nTo DRINK: 'drink' or 'drink potion'.\nTo SPEAK: 'say [message]' or simply '[message] (starting with single quote ').\nTo SHOUT: 'shout [message]' or simply ![message] (starting with exclamation mark).\nMy knowledge expands as your journey unfolds.", 'system');
                shouldEmit = false; 
            } else if (canonicalAction === "cast") { 
                 if (messageContent) {
                    commandToSend.details = { spellName: messageContent.split(' ')[0], targetDirection: messageContent.split(' ').length > 1 ? messageContent.split(' ')[1] : null }; 
                    // Server will confirm targeting and mana
                 } else { 
                    addLogMessage(`Tome asks: Cast what, O Wizard? You must name the incantation.`, 'event-bad');
                    shouldEmit = false;
                 }
            } else if (canonicalAction === "drink") {
                if (messageContent && !(messageContent.toLowerCase().includes("potion") || messageContent.toLowerCase().includes("flask"))) {
                    addLogMessage(`Tome queries: Drink what specifically? If a potion, just 'drink' or 'drink potion'.`, 'event-bad');
                    shouldEmit = false; 
                } else {
                    commandToSend.type = 'drink_potion'; // Standardize type for server
                    // Server will handle potion logic and messages
                }
            } else if (canonicalAction === "say" || canonicalAction === "shout") {
                if (messageContent && messageContent.length > 0) {
                    commandToSend.details = { message: messageContent };
                } else { 
                    addLogMessage(`Tome asks: ${canonicalAction.charAt(0).toUpperCase() + canonicalAction.slice(1)} what, O Wizard? Your words are lost to the ether.`, 'event-bad');
                    shouldEmit = false;
                }
            }
            else { // Catch-all for actions not fully implemented on client parsing side
                addLogMessage(`Tome sighs: The arcane art of "${canonicalAction}" is yet beyond your grasp, or perhaps my understanding of your intent.`, 'event-bad');
                shouldEmit = false;
            }

            if (shouldEmit) {
                console.log("Emitting command to server:", commandToSend);
                socket.emit('queue_command', commandToSend);
            }
            commandInput.focus();
        });
        
        // Debug functions (can be removed or kept for testing)
        window.toggleRainDebug = function() { 
            const wasRaining = globalWeather.isRaining; 
            globalWeather.isRaining = !globalWeather.isRaining;
             if (currentSceneData.InsideID === 0) { 
                if (globalWeather.isRaining && !wasRaining) {
                    if(showDebugInfo) addLogMessage("Tome shivers (DEBUG): The skies open and a steady rain begins to fall.", "system");
                } else if (!globalWeather.isRaining && wasRaining) {
                    if(showDebugInfo) addLogMessage("Tome brightens (DEBUG): The rain subsides, leaving the air fresh.", "system");
                }
            }
            updateWeatherEffects();
        };
         window.toggleInsideDebug = function() { 
            currentSceneData.InsideID = currentSceneData.InsideID === 0 ? 1 : 0;
            currentSceneData.name = currentSceneData.InsideID === 0 ? "The Overworld (Debug)" : "A Cozy Hut (Debug)"; 
            if(showDebugInfo) addLogMessage(`Tome notes (DEBUG): You are now ${currentSceneData.InsideID === 0 ? 'Outdoors' : 'Indoors ('+currentSceneData.name+')'}.`, "system");
            updateStatus();
            updateWeatherEffects();
        };
        
        // --- Initial Page Load Setup ---
        gameCanvas.textContent = "Initializing Realm...";
        if (commandInput) { commandInput.focus(); }
        
        // Load preferences from localStorage (done again here for clarity, could be a function)
        const savedDebugInfoOnLoad = localStorage.getItem('showDebugInfo');
        showDebugInfo = savedDebugInfoOnLoad !== null ? JSON.parse(savedDebugInfoOnLoad) : false;
        debugInfoToggle.checked = showDebugInfo;
        rainIntensityControl.style.display = showDebugInfo ? 'block' : 'none';

        const savedLocalCommandsOnLoad = localStorage.getItem('useLocalCommands');
        useLocalCommands = savedLocalCommandsOnLoad !== null ? JSON.parse(savedLocalCommandsOnLoad) : true;
        localCommandsToggle.checked = useLocalCommands;

        const savedRainIntensityOnLoad = localStorage.getItem('rainIntensity');
        globalWeather.intensity = savedRainIntensityOnLoad !== null ? parseFloat(savedRainIntensityOnLoad) : 0.1;
        rainIntensitySlider.value = globalWeather.intensity;

        updateStatus("Awaiting connection to the Ethereal Plane..."); // Initial status before socket connection
        updateWeatherEffects(); // Initial weather setup based on defaults
        addLogMessage("Tome unfurls its pages: Welcome, Wizard. The Ethereal Waves await your command.", 'welcome-message');

    </script>
</body>
</html>