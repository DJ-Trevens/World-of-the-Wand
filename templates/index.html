<!DOCTYPE html>
<html lang = "en">
<head>
    <meta charset = "UTF-8">
    <meta name = "viewport" content = "width = device-width, initial-scale = 1.0">
    <title>World of the Wand - Tome of Echoes</title>
    <link rel = "stylesheet" href = "{{url_for('game.static', filename = 'style.css')}}">

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script src="{{url_for('game.static', filename='game_texts.js')}}"></script>
    <script>
        const socket = io({path: "/world-of-the-wand/socket.io"});
    </script>
</head>
<body> 
    <div class="main-ui-container">
        <div class="left-panel">
            <div id="commandLog"></div>
        </div>

        <div class="right-panel">
            <div id="mainHeaderStatusContainer">
                <div id="debugMenu">
                    <label>
                        <input type="checkbox" id="debugInfoToggle"> Debug Info
                    </label>
                    <div id="rainIntensityControl">
                        <label>
                            Rain Intensity: <input type="range" id="rainIntensitySlider" min="0" max="1" step="0.05">
                        </label>
                    </div>
                    <button id="themeToggle" title="Switch to Light Mode">‚òÄÔ∏è</button>
                </div>
                <div id="mainHeaderStatus">Welcome to the World of the Wand!</div>
            </div>

            <div id="gameCanvasContainer">
                <div id="gameCanvas">Initializing Realm...</div>
                <div id="rainOverlay"></div>
            </div>
            
            <div id="commandInputBox">
                <form id="commandForm">
                    <label for="commandText">
                        <span id="tickIndicator">‚óè</span>Inscribe Thy Will:
                    </label>
                    <div id="commandText" contenteditable="true" spellcheck="false" autocomplete="off" role="textbox" aria-multiline="false"></div>
                    <button type="submit">Commit</button>
                </form>
            </div>
        </div>
    </div>

    <script>
        const gameCanvas = document.getElementById('gameCanvas');
        const gameCanvasContainer = document.getElementById('gameCanvasContainer');
        const rainOverlay = document.getElementById('rainOverlay');
        const mainHeaderStatus = document.getElementById('mainHeaderStatus');
        const commandLog = document.getElementById('commandLog');
        const commandForm = document.getElementById('commandForm');
        const commandInput = document.getElementById('commandText');
        const tickIndicator = document.getElementById('tickIndicator');
        const debugInfoToggle = document.getElementById('debugInfoToggle');
        const rainIntensitySlider = document.getElementById('rainIntensitySlider');
        const rainIntensityControl = document.getElementById('rainIntensityControl');
        const themeToggleButton = document.getElementById('themeToggle');

        const MOON_EMOJI = 'üåô'; 
        const SUN_EMOJI = '‚òÄÔ∏è'; 

        let showDebugInfo = false; 
        let selfPlayer = null;
        let otherPlayers = {}; 
        let myPlayerID = null; 
        let GRID_WIDTH = 20; 
        let GRID_HEIGHT = 15;
        let GAME_TICK_RATE = 0.75;
        let OBSERVABLE_DEPTH = 17;
        let prevSelfPlayerState = null;
        let currentSceneData = { InsideID: 0, name: "The Whispering Plains" };
        let globalWeather = { isRaining: true, intensity: 0.1 };
        let rainInterval = null;
        const RAIN_INTERVAL_DELAY = 50; 
        let isDragging = false;
        let startDragX, startDragY;
        let currentPanX = 0, currentPanY = 0; 
        let targetPanX = 0, targetPanY = 0;   
        const DEFAULT_FONT_SIZE_PX = 18;
        const DEFAULT_LINE_HEIGHT_MULTIPLIER = 0.9;
        const DEFAULT_CHAR_WIDTH_FALLBACK = DEFAULT_FONT_SIZE_PX * 0.6;
        const DEFAULT_CHAR_HEIGHT_FALLBACK = DEFAULT_FONT_SIZE_PX * DEFAULT_LINE_HEIGHT_MULTIPLIER;
        let charRenderWidth = DEFAULT_CHAR_WIDTH_FALLBACK; 
        let charRenderHeight = DEFAULT_CHAR_HEIGHT_FALLBACK; 
        let charSizeEstimatedAtLeastOnce = false; // Changed from charSizeEstimated to reflect its purpose
        let initialCenteringDone = false;
        let initialUIDone = false; 
        const FOG_CHAR = '‚ñë'; 
        const FLOOR_CHAR = '¬∑'; 
        const AURA_VISION_RANGE = 1;

        function applyTheme(theme) {
            if (theme === 'light') {
                document.body.classList.add('light-theme');
                document.body.classList.remove('dark-theme');
                themeToggleButton.textContent = SUN_EMOJI; // Show SUN to indicate it will switch to Light mode
                themeToggleButton.title = "Switch to Light Mode";
            } else { 
                document.body.classList.add('dark-theme'); 
                document.body.classList.remove('light-theme');
                themeToggleButton.textContent = MOON_EMOJI; // Show MOON to indicate it will switch to Dark mode
                themeToggleButton.title = "Switch to Dark Mode";
            }
            localStorage.setItem('worldOfTheWandTheme', theme);
        }

        function toggleTheme() {
            const currentThemeIsDark = document.body.classList.contains('dark-theme') || (!localStorage.getItem('worldOfTheWandTheme') && !window.matchMedia('(prefers-color-scheme: light)').matches);
            applyTheme(currentThemeIsDark ? 'light' : 'dark');
        }
        themeToggleButton.addEventListener('click', toggleTheme);

        function initializeTheme() {
            const savedTheme = localStorage.getItem('worldOfTheWandTheme');
            if (savedTheme) {
                applyTheme(savedTheme);
            } else {
                applyTheme(window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark');
            }
        }
        initializeTheme();

        function get_dx_dy_from_direction_str(s) { /* ... (full implementation) ... */ }
        function get_direction_str_from_dx_dy(dx, dy) { /* ... (full implementation) ... */ }
        function getRelativeCoords(playerX, playerY, playerFacingChar, targetX, targetY) { /* ... (full implementation) ... */ }
        function manhattanDistance(x1, y1, x2, y2) { /* ... (full implementation) ... */ }
        function isVisible(observerX, observerY, observerChar, targetX, targetY, scry = false) { /* ... (full implementation) ... */ }
        
        function addLogMessage(message, type = 'lore') {
            const logEntry = document.createElement('div');
            let displayStyle = 'ink';
            switch (type) {
                case 'event-bad': case 'chat-shout': case 'server-major-event': 
                case 'player-trade': case 'player-damage': case 'welcome-message': 
                    displayStyle = 'mana'; break;
                case 'system': case 'event-good': case 'spell-cast': 
                case 'lore': case 'user-input': case 'chat-say':          
                default: displayStyle = 'ink'; break;
            }
            logEntry.classList.add('log-entry', `log-style-${displayStyle}`, `log-type-${type}`);
            logEntry.textContent = message; 
            commandLog.appendChild(logEntry);
            requestAnimationFrame(() => { commandLog.scrollTop = commandLog.scrollHeight; });
        }
        
        function logRandomizedEvent(mainKey, subKey, placeholders = {}, messageType = 'lore') {
            const message = getRandomGameText(mainKey, subKey, placeholders);
            addLogMessage(message, messageType);
        }

        function updateStatus(statusText) { /* ... (full implementation) ... */ }
        
        function estimateCharacterSize(context = "unknown") {
            console.log(`[estimateCharacterSize context: ${context}] Start. Canvas text: "${gameCanvas.textContent.substring(0,30).replace(/\n/g, "\\n")}..." charSizeEstimatedAtLeastOnce: ${charSizeEstimatedAtLeastOnce}`);
            const computedStyle = getComputedStyle(gameCanvas);
            const usesPlaceholderText = !gameCanvas.textContent || gameCanvas.textContent.startsWith("Initializing Realm...") || gameCanvas.textContent.startsWith("The mists");

            if (usesPlaceholderText || computedStyle.fontSize === "0px" || !computedStyle.fontFamily || parseFloat(computedStyle.fontSize) < 5) {
                charRenderWidth = DEFAULT_CHAR_WIDTH_FALLBACK;
                charRenderHeight = DEFAULT_CHAR_HEIGHT_FALLBACK;
                console.warn(`[estimateCharacterSize context: ${context}] Using PREDEFINED FALLBACK (placeholder or invalid style): W=${charRenderWidth.toFixed(2)}, H=${charRenderHeight.toFixed(2)}`);
                charSizeEstimatedAtLeastOnce = true; 
                return; 
            }

            console.log(`[estimateCharacterSize context: ${context}] Attempting ACCURATE char size with tempSpan.`);
            const tempSpan = document.createElement('span');
            tempSpan.style.fontFamily = computedStyle.fontFamily;
            tempSpan.style.fontSize = computedStyle.fontSize;
            tempSpan.style.lineHeight = computedStyle.lineHeight;
            tempSpan.style.whiteSpace = 'pre';
            tempSpan.style.visibility = 'hidden';
            tempSpan.style.position = 'absolute';
            tempSpan.textContent = 'M';
            document.body.appendChild(tempSpan);

            let measuredWidth = tempSpan.offsetWidth;
            let measuredHeight;
            const fs = parseFloat(computedStyle.fontSize);
            let lhNumeric = parseFloat(computedStyle.lineHeight); 

            if (computedStyle.lineHeight === "normal") measuredHeight = fs * 1.2; 
            else if (!isNaN(lhNumeric) && computedStyle.lineHeight.includes('px')) measuredHeight = lhNumeric; 
            else if (!isNaN(lhNumeric) && lhNumeric > 0.1) measuredHeight = fs * lhNumeric;
            else measuredHeight = fs * DEFAULT_LINE_HEIGHT_MULTIPLIER; 
            
            document.body.removeChild(tempSpan);

            if (measuredWidth > 0 && measuredHeight > 0) {
                charRenderWidth = measuredWidth;
                charRenderHeight = measuredHeight;
            } else {
                charRenderWidth = DEFAULT_CHAR_WIDTH_FALLBACK;
                charRenderHeight = DEFAULT_CHAR_HEIGHT_FALLBACK;
                console.warn(`[estimateCharacterSize context: ${context}] tempSpan method yielded non-positive dimensions. Reverting to PREDEFINED FALLBACK.`);
            }
            console.log(`[estimateCharacterSize context: ${context}] Char size (W x H): ${charRenderWidth.toFixed(2)} x ${charRenderHeight.toFixed(2)}`);
            charSizeEstimatedAtLeastOnce = true;
        }

        function drawGrid() { /* ... (full implementation) ... */ }
        function startRainEffect(intensity) { /* ... (full implementation) ... */ }
        function stopRainEffect() { /* ... (full implementation) ... */ }
        function updateWeatherEffects() { /* ... (full implementation) ... */ }
        gameCanvasContainer.addEventListener('mousedown', (e) => { /* ... (full implementation) ... */ });
        window.addEventListener('mousemove', (e) => { /* ... (full implementation) ... */ });
        window.addEventListener('mouseup', (e) => { /* ... (full implementation) ... */ });
        gameCanvasContainer.addEventListener('mouseleave', () => { /* ... (full implementation) ... */ });
        
        function centerViewOnPlayer(context = "unknown") {
            const containerHeight = gameCanvasContainer.clientHeight;
            const containerWidth = gameCanvasContainer.clientWidth;
            console.log(`[centerViewOnPlayer context: ${context}] Called. Container (W:${containerWidth}, H:${containerHeight}), Char (W:${charRenderWidth.toFixed(2)}, H:${charRenderHeight.toFixed(2)}) charSizeEstimatedAtLeastOnce: ${charSizeEstimatedAtLeastOnce}`);
            
            if (!selfPlayer || !charSizeEstimatedAtLeastOnce || GRID_WIDTH === 0 || GRID_HEIGHT === 0 || containerHeight <= 0 || containerWidth <=0) {
                 console.warn(`[centerViewOnPlayer context: ${context}] PRECONDITIONS NOT MET. Aborting centering.`);
                 currentPanX = 0; currentPanY = 0;
                 if(gameCanvas) gameCanvas.style.transform = `translate(${currentPanX}px, ${currentPanY}px)`;
                return; 
            }
            
            // If char dimensions seem off, try ONE re-estimation if context suggests it's not an emergency.
            // The "emergency" re-estimate happens if the first try with bad values also fails.
            if ((charRenderWidth <= 0 || charRenderHeight <= 0 || charRenderHeight > 50) && context !== "centerView_emergency_reestimate_from_game_update_recentering" && context !== "centerView_emergency_reestimate_from_initial_state_delayed_final_centering") { 
                console.warn(`[centerViewOnPlayer context: ${context}] Unreliable char dimensions (W:${charRenderWidth.toFixed(2)}, H:${charRenderHeight.toFixed(2)}). Forcing re-estimation.`);
                estimateCharacterSize(`centerView_reestimate_from_${context}`); // Let this function update globals
                
                // After re-estimation, if still bad, use absolute defaults for this attempt.
                if (charRenderWidth <= 0 || charRenderHeight <= 0 || charRenderHeight > 50) {
                    console.error(`[centerViewOnPlayer context: ${context}] Re-estimation FAILED. Using hardcoded default dimensions for this centering call.`);
                    addLogMessage("Tome's script sputters: Visual calibration failed again! Using fallback dimensions.", 'event-bad');
                    charRenderWidth = DEFAULT_CHAR_WIDTH_FALLBACK; 
                    charRenderHeight = DEFAULT_CHAR_HEIGHT_FALLBACK;
                }
            }
            
            const playerVisualCenterX = (selfPlayer.x * charRenderWidth) + (charRenderWidth / 2);
            const playerVisualCenterY = (selfPlayer.y * charRenderHeight) + (charRenderHeight / 2);
            targetPanX = (containerWidth / 2) - playerVisualCenterX;
            targetPanY = (containerHeight / 2) - playerVisualCenterY;
            currentPanX = targetPanX; currentPanY = targetPanY;
            console.log(`[centerViewOnPlayer context: ${context}] Centering: Player(${selfPlayer.x},${selfPlayer.y}), Pan(X:${targetPanX.toFixed(2)}, Y:${targetPanY.toFixed(2)})`);
            if(gameCanvas) gameCanvas.style.transform = `translate(${currentPanX}px, ${currentPanY}px)`;
        }

        debugInfoToggle.addEventListener('change', (event) => { /* ... (full implementation) ... */ });
        rainIntensitySlider.addEventListener('input', (event) => { /* ... (full implementation) ... */ });
        
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                if (entry.target === gameCanvasContainer) {
                    const newHeight = entry.contentRect.height;
                    const newWidth = entry.contentRect.width;
                    console.log(`[ResizeObserver] gameCanvasContainer new dimensions: W=${newWidth}, H=${newHeight}`);
                    
                    if (newHeight > 0 && newWidth > 0 && selfPlayer && !initialCenteringDone) {
                        console.log(`[ResizeObserver] Container has valid dimensions. Attempting initial setup & centering.`);
                        if (!charSizeEstimatedAtLeastOnce || charRenderWidth <=0 || charRenderHeight <=0 ) {
                           estimateCharacterSize("ResizeObserver_triggered_estimate");
                        }
                        centerViewOnPlayer("ResizeObserver_initial_center");
                        initialCenteringDone = true; 
                        if (!initialUIDone) {
                            updateStatus(); updateWeatherEffects(); 
                            logRandomizedEvent('LORE', 'WELCOME', { playerId: myPlayerID }, 'welcome-message');
                            if (currentSceneData.InsideID === 0 && globalWeather.isRaining) logRandomizedEvent('LORE', 'INITIAL_RAIN', {}, 'system');
                            initialUIDone = true;
                        }
                    }
                }
            }
        });
        if (gameCanvasContainer) resizeObserver.observe(gameCanvasContainer);

        socket.on('connect', () => { /* ... (full implementation) ... */ });
        socket.on('connect_error', (err) => { /* ... (full implementation) ... */ });

        socket.on('initial_game_data', (data) => {
            console.log("Received 'initial_game_data':", data);
            if (!data || !data.player_data || typeof data.grid_width !== 'number' || typeof data.grid_height !== 'number') {
                logRandomizedEvent('LORE', 'CORRUPT_MANIFESTATION_SERVER', {}, 'event-bad');
                gameCanvas.textContent = "Error: Corrupted initial data."; return;
            }
            selfPlayer = data.player_data; myPlayerID = selfPlayer.id; 
            GRID_WIDTH = data.grid_width; GRID_HEIGHT = data.grid_height; GAME_TICK_RATE = data.tick_rate;
            otherPlayers = {}; 
            if (data.other_players_in_scene) data.other_players_in_scene.forEach(p => { if (p.id !== myPlayerID) otherPlayers[p.id] = p; });
            prevSelfPlayerState = { ...selfPlayer };
            
            const savedDebugInfo = localStorage.getItem('showDebugInfo'); showDebugInfo = savedDebugInfo !== null ? JSON.parse(savedDebugInfo) : false; debugInfoToggle.checked = showDebugInfo; rainIntensityControl.style.display = showDebugInfo ? 'block' : 'none';
            const savedRainIntensity = localStorage.getItem('rainIntensity'); globalWeather.intensity = savedRainIntensity !== null ? parseFloat(savedRainIntensity) : 0.1; rainIntensitySlider.value = globalWeather.intensity;

            document.fonts.ready.then(() => {
                console.log("Fonts ready. Initial data processed.");
                if (selfPlayer) {
                    estimateCharacterSize("initial_data_fonts_ready"); // Ensure an initial estimate
                    drawGrid(); updateStatus(); 

                    if (gameCanvasContainer.clientHeight > 0 && !initialCenteringDone) {
                        console.log("Container has height post-draw. Ensuring centering & UI setup.");
                        centerViewOnPlayer("initial_data_direct_center_attempt");
                        initialCenteringDone = true;
                        if(!initialUIDone){
                             updateWeatherEffects(); 
                             logRandomizedEvent('LORE', 'WELCOME', { playerId: myPlayerID }, 'welcome-message');
                             if (currentSceneData.InsideID === 0 && globalWeather.isRaining) logRandomizedEvent('LORE', 'INITIAL_RAIN', {}, 'system');
                             initialUIDone = true;
                        }
                    } else if (gameCanvasContainer.clientHeight <= 0 && !initialCenteringDone) {
                        console.warn("Container height 0. ResizeObserver should handle. Setting fallback timeout.");
                        setTimeout(() => { // Fallback
                            if (!initialCenteringDone && gameCanvasContainer.clientHeight > 0) {
                                console.log("Fallback timeout: Container has height. Centering.");
                                if (!charSizeEstimatedAtLeastOnce) estimateCharacterSize("initial_data_timeout_fallback_estimate");
                                centerViewOnPlayer("initial_data_timeout_fallback_center");
                                initialCenteringDone = true;
                                if (!initialUIDone) { 
                                    updateWeatherEffects(); 
                                    logRandomizedEvent('LORE', 'WELCOME', { playerId: myPlayerID, fallback: "(fallback)" }, 'welcome-message');
                                    if (currentSceneData.InsideID === 0 && globalWeather.isRaining) logRandomizedEvent('LORE', 'INITIAL_RAIN', {}, 'system');
                                    initialUIDone = true;
                                }
                            } else if (!initialCenteringDone) {
                                console.error("Container height still 0 after fallback timeout. Centering failed.");
                                logRandomizedEvent('LORE', 'CENTERING_ERROR', {}, 'event-bad');
                            }
                        }, 300); 
                    } else if (initialCenteringDone && !initialUIDone) { // If ResizeObserver centered but UI updates didn't run
                        updateWeatherEffects(); 
                        logRandomizedEvent('LORE', 'WELCOME', { playerId: myPlayerID, observer: "(observer)" }, 'welcome-message');
                        if (currentSceneData.InsideID === 0 && globalWeather.isRaining) logRandomizedEvent('LORE', 'INITIAL_RAIN', {}, 'system');
                        initialUIDone = true;
                    }
                } else {
                    logRandomizedEvent('LORE', 'MANIFESTATION_FAILED_NO_PLAYER_DATA', {}, 'event-bad');
                }
            }).catch(err => { /* ... (full error handling as before) ... */ });
        });

        socket.on('player_entered_your_scene', (newPlayerData) => { /* ... (full implementation as before) ... */ });
        socket.on('player_exited_your_scene', (exitedPlayerData) => { /* ... (full implementation as before) ... */ });
        
        socket.on('lore_message', (data) => {
            if (data.messageKey && GAME_TEXTS[data.messageKey.split('.')[0]]) { 
                const keys = data.messageKey.split('.');
                const mainKey = keys[0];
                const subKey = keys.length > 1 ? keys.slice(1).join('.') : null; 
                logRandomizedEvent(mainKey, subKey, data.placeholders || { message: data.message }, data.type || 'lore');
            } else {
                 logRandomizedEvent('GENERIC', (data.type || 'lore').toUpperCase(), { message: data.message || "An unknown lore event occurred." }, data.type || 'lore');
            }
        });
        
        socket.on('chat_message', (data) => { /* ... (full implementation as before) ... */ });
        
        let tickFlashTimeout = null;
        socket.on('game_update', (data) => {
            if (!selfPlayer || !myPlayerID) { return; }
            console.log("Client received 'game_update'. Self player data from server:", data.self_player_data);
            
            if(tickIndicator) { /* ... (tick flash logic) ... */ }

            const oldSceneX = selfPlayer.scene_x; const oldSceneY = selfPlayer.scene_y;
            const oldX = selfPlayer.x; const oldY = selfPlayer.y; const oldChar = selfPlayer.char;

            selfPlayer = data.self_player_data;
            otherPlayers = {}; 
            if(data.visible_other_players) data.visible_other_players.forEach(p => { if (p.id !== myPlayerID) otherPlayers[p.id] = p; });
            updateStatus(); 

            const sceneChanged = selfPlayer.scene_x !== oldSceneX || selfPlayer.scene_y !== oldSceneY;
            const positionChanged = selfPlayer.x !== oldX || selfPlayer.y !== oldY;
            const facingChanged = selfPlayer.char !== oldChar;

            if (sceneChanged) { /* Server should send a specific lore_message for this */ }
            else if (positionChanged) logRandomizedEvent('PLAYER_MOVE', null, {x: selfPlayer.x, y: selfPlayer.y, direction: getDirectionWord(selfPlayer.char)}, 'lore');
            else if (facingChanged) logRandomizedEvent('PLAYER_TURN', null, {direction: getDirectionWord(selfPlayer.char), x: selfPlayer.x, y: selfPlayer.y}, 'lore');

            if (sceneChanged || positionChanged || facingChanged) {
                 if (!isDragging) {
                    if(!charSizeEstimatedAtLeastOnce || charRenderWidth <= 0 || charRenderHeight <= 0 || charRenderHeight > 50){
                        estimateCharacterSize("game_update_pre_recenter_estimate");
                    }
                    // Do not use requestAnimationFrame here as it might cause a feedback loop if game_update is frequent
                    setTimeout(() => centerViewOnPlayer("game_update_recentering"), 0); 
                }
            }
            prevSelfPlayerState = { ...selfPlayer }; 
            drawGrid(); 
            if (!charSizeEstimatedAtLeastOnce && gameCanvas.textContent && !gameCanvas.textContent.startsWith("The mists") && !gameCanvas.textContent.startsWith("Initializing Realm...")) {
                 estimateCharacterSize("game_update_reestimate");
                 if(!isDragging) setTimeout(() => centerViewOnPlayer("game_update_after_reestimate_centering"), 0);
            }
            updateWeatherEffects(); 
        });

        function getDirectionWord(char) {
            if (char === '^') return "North"; if (char === 'v') return "South";
            if (char === '<') return "West";  if (char === '>') return "East";
            return "an unknown direction";
        }
        socket.on('action_feedback', (data) => { /* ... (full implementation as before) ... */ });
        socket.on('disconnect', (reason) => { /* ... (full implementation as before) ... */ });
        const ACTION_ALIASES = { /* ... (full implementation as before) ... */ };
        const DIRECTION_ALIASES = { /* ... (full implementation as before) ... */ };
        function parseAction(actionWord) { /* ... (full implementation as before) ... */ }
        function parseDirection(directionStr, curFacing) { /* ... (full implementation as before) ... */ }
        commandInput.addEventListener('keydown', (event) => { /* ... (full implementation as before) ... */ });
        commandForm.addEventListener('submit', (event) => { /* ... (full implementation as before, server-authoritative) ... */ });
        
        window.toggleRainDebug = function() { /* ... (full implementation as before) ... */ };
        window.toggleInsideDebug = function() { /* ... (full implementation as before) ... */ };
        
        gameCanvas.textContent = "Initializing Realm...";
        if (commandInput) { commandInput.focus(); }
        const savedDebugInfoOnLoad = localStorage.getItem('showDebugInfo'); showDebugInfo = savedDebugInfoOnLoad !== null ? JSON.parse(savedDebugInfoOnLoad) : false; debugInfoToggle.checked = showDebugInfo; rainIntensityControl.style.display = showDebugInfo ? 'block' : 'none';
        const savedRainIntensityOnLoad = localStorage.getItem('rainIntensity'); globalWeather.intensity = savedRainIntensityOnLoad !== null ? parseFloat(savedRainIntensityOnLoad) : 0.1; rainIntensitySlider.value = globalWeather.intensity;
        updateStatus("Awaiting connection to the Ethereal Plane..."); 
        updateWeatherEffects(); 
        logRandomizedEvent('LORE', 'WELCOME_INITIAL', {}, 'welcome-message');

    </script>
</body>
</html>