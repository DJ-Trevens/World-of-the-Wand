<!DOCTYPE html>
<html lang = "en">
<head>
    <meta charset = "UTF-8">
    <meta name = "viewport" content = "width = device-width, initial-scale = 1.0, user-scalable=no">
    <title>World of the Wand - Tome of Echoes</title>
    <link rel = "stylesheet" href = "{{url_for('game.static', filename = 'style.css')}}">

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script src="{{url_for('game.static', filename='game_texts.js')}}"></script>
    <script>
        const socket = io({path: "/world-of-the-wand/socket.io"});
    </script>
</head>
<body>
    <div class="main-ui-container">
        <div class="left-panel">
            <div id="commandLog"></div>
            <div id="debugAndAuxiliaryPanel" style="display:none;">
                <div class="debug-panel-content"> {/* New wrapper for scrolling */}
                    <div class="debug-section debug-info-section">
                        <h4>Debug Stats</h4>
                        <div id="clientDebugInfo">
                            <div>Self: <span id="dbgSelfPlayer">N/A</span></div>
                            <div>Others: <span id="dbgOtherPlayersCount">0</span></div>
                            <div>NPCs: <span id="dbgNpcsCount">0</span></div>
                            <div>
                                <span id="serverHeartbeatIndicator" class="heartbeat-indicator-inline"></span> Server Heartbeat: <span id="dbgLastUpdate">Never</span>
                            </div>
                            <div>
                                <span id="simulatedHeartbeatIndicator" class="heartbeat-indicator-inline"></span> Sim. Heartbeat: <span id="dbgSimulating">false</span>
                            </div>
                        </div>
                    </div>
                    <div class="debug-section debug-context-section">
                        <h4>Context</h4>
                        <div id="debugContextInfo">
                            <div>Scene: <span id="dbgSceneCoords">N/A</span> (<span id="dbgSceneName">N/A</span>)</div>
                            <div>Location: <span id="dbgLocationType">N/A</span></div>
                            <div>Player Pos: <span id="dbgPlayerChar"></span> (<span id="dbgPlayerCoords">N/A</span>)</div>
                            <div>Status: <span id="dbgPlayerStatus">N/A</span></div>
                        </div>
                    </div>
                    <div class="debug-section debug-config-section">
                        <h4>Debug Config</h4>
                        <div id="rainIntensityControl" class="debug-control-item">
                            <label for="rainIntensitySlider">Rain Intensity:</label>
                            <input type="range" id="rainIntensitySlider" min="0" max="1" step="0.05">
                        </div>
                        <div id="simulateHeartbeatControl" class="debug-control-item">
                             <label for="simulateHeartbeatToggle">Simulate Client Heartbeat:</label>
                             <input type="checkbox" id="simulateHeartbeatToggle">
                        </div>
                        <div class="debug-control-item">
                             <label for="themeToggle">Toggle Theme:</label>
                             <button id="themeToggle" title="Switch to Light Mode">‚òÄÔ∏è</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="left-panel-footer">
                <div class="debug-master-toggle">
                     <label>
                        <input type="checkbox" id="debugInfoToggle"> Show Debug Glyphs
                    </label>
                </div>
            </div>
        </div>

        <div class="right-panel">
            <div id="mainHeaderStatusContainer">
                <div id="mainHeaderStatus">World of the Wand</div>
            </div>

            <div id="gameCanvasContainer">
                <canvas id="gameCanvas">Your browser does not support the canvas element.</canvas>
                <div id="rainOverlay"></div>
            </div>

            <div id="commandInputBox">
                <form id="commandForm">
                    <label for="commandText">
                         Inscribe Your Will:
                    </label>
                    <div id="commandText" contenteditable="true" spellcheck="false" autocomplete="off" role="textbox" aria-multiline="false" placeholder="Inscribe Your Will..."></div>
                    <button type="submit">Enact</button>
                </form>
            </div>
        </div>
    </div>

    <script>
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d');
        const gameCanvasContainer = document.getElementById('gameCanvasContainer');
        const rainOverlay = document.getElementById('rainOverlay');
        const mainHeaderStatus = document.getElementById('mainHeaderStatus');
        const commandLog = document.getElementById('commandLog');
        const commandForm = document.getElementById('commandForm');
        const commandInput = document.getElementById('commandText');
        const serverHeartbeatIndicator = document.getElementById('serverHeartbeatIndicator');
        const simulatedHeartbeatIndicator = document.getElementById('simulatedHeartbeatIndicator');
        const debugInfoToggle = document.getElementById('debugInfoToggle');
        const rainIntensitySlider = document.getElementById('rainIntensitySlider');
        // const rainIntensityControl = document.getElementById('rainIntensityControl'); // No longer needed as direct parent
        const themeToggleButton = document.getElementById('themeToggle');
        const simulateHeartbeatToggle = document.getElementById('simulateHeartbeatToggle');
        // const simulateHeartbeatControl = document.getElementById('simulateHeartbeatControl'); // No longer needed
        // const clientDebugInfo = document.getElementById('clientDebugInfo'); // Variables below target specific spans
        const debugAndAuxiliaryPanel = document.getElementById('debugAndAuxiliaryPanel');

        const dbgSelfPlayer = document.getElementById('dbgSelfPlayer');
        const dbgOtherPlayersCount = document.getElementById('dbgOtherPlayersCount');
        const dbgNpcsCount = document.getElementById('dbgNpcsCount');
        const dbgLastUpdate = document.getElementById('dbgLastUpdate');
        const dbgSimulating = document.getElementById('dbgSimulating');

        // New debug context spans
        const dbgSceneCoords = document.getElementById('dbgSceneCoords');
        const dbgSceneName = document.getElementById('dbgSceneName');
        const dbgLocationType = document.getElementById('dbgLocationType');
        const dbgPlayerChar = document.getElementById('dbgPlayerChar');
        const dbgPlayerCoords = document.getElementById('dbgPlayerCoords');
        const dbgPlayerStatus = document.getElementById('dbgPlayerStatus');


        const MOON_EMOJI = 'üåô';
        const SUN_EMOJI = '‚òÄÔ∏è';

        let showDebugInfoState = false;
        let selfPlayer = null;
        let otherPlayers = {};
        let visibleNPCs = [];
        let visibleTerrain = { walls: [], water: [] };
        let myPlayerID = null;
        let GRID_WIDTH = 20;
        let GRID_HEIGHT = 15;
        let GAME_HEARTBEAT_RATE = 0.75;
        let prevSelfPlayerState = null;
        let currentSceneData = { InsideID: 0, name: "The Whispering Plains" }; // Client-side assumption, server is truth
        let globalWeather = { isRaining: true, intensity: 0.25 }; // Client-side assumption
        let rainInterval = null;
        const RAIN_INTERVAL_DELAY = 50;
        let isDragging = false;
        let startDragX, startDragY;
        let currentPanX = 0;
        let currentPanY = 0;

        const DEFAULT_FONT_SIZE_PX = 18;
        const X_STRETCH_FACTOR = 1.15;
        const DEFAULT_CHAR_WIDTH_FALLBACK = (DEFAULT_FONT_SIZE_PX * 0.6) * X_STRETCH_FACTOR;
        const DEFAULT_CHAR_HEIGHT_FALLBACK = DEFAULT_FONT_SIZE_PX * 0.9;

        let charRenderWidth = DEFAULT_CHAR_WIDTH_FALLBACK;
        let charRenderHeight = DEFAULT_CHAR_HEIGHT_FALLBACK;
        let charSizeEstimatedAtLeastOnce = false;
        let initialCenteringDone = false;
        let initialUIDone = false;

        const FOG_CHAR = '‚ñí';
        const FLOOR_CHAR = '¬∑';
        const WALL_CHAR = '‚ñì';
        const WATER_CHAR = '~';
        const PIXIE_CHAR_CLIENT = '*';
        const AURA_VISION_RANGE = 1; // For client-side immediate visibility checks if any

        let currentGameZoomFactor = 1.4;
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 3.0;
        const ZOOM_INCREMENT = 0.05;

        let simulateServerHeartbeatEnabled = false;
        let simulatedHeartbeatInterval = null;
        let serverHeartbeatFlashTimeout = null;
        let simulatedHeartbeatFlashTimeout = null;


        function updateGameTransform() {
            gameCanvas.style.transform = `translate(${currentPanX}px, ${currentPanY}px) scale(${currentGameZoomFactor})`;
        }

        function applyTheme(theme) {
            if (theme === 'light') {
                document.body.classList.add('light-theme');
                document.body.classList.remove('dark-theme');
                themeToggleButton.textContent = MOON_EMOJI;
                themeToggleButton.title = "Switch to Dark Mode";
            } else {
                document.body.classList.add('dark-theme');
                document.body.classList.remove('light-theme');
                themeToggleButton.textContent = SUN_EMOJI;
                themeToggleButton.title = "Switch to Light Mode";
            }
            localStorage.setItem('worldOfTheWandTheme', theme);
            if(selfPlayer && charSizeEstimatedAtLeastOnce) drawGrid();
        }

        function toggleTheme() {
            const currentThemeIsDark = document.body.classList.contains('dark-theme');
            applyTheme(currentThemeIsDark ? 'light' : 'dark');
        }
        themeToggleButton.addEventListener('click', toggleTheme);

        function initializeTheme() {
            const savedTheme = localStorage.getItem('worldOfTheWandTheme');
            if (savedTheme) { applyTheme(savedTheme); }
            else { applyTheme(window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark'); }
        }

        function get_dx_dy_from_direction_str(s) {
            const mapping = {'^': [0, -1], 'v': [0, 1], '<': [-1, 0], '>': [1, 0]};
            return mapping[s] || [0, 0];
        }
        function get_direction_str_from_dx_dy(dx, dy) {
            const mapping = {"0,-1": '^', "0,1": 'v', "-1,0": '<', "1,0": '>'};
            return mapping[`${dx},${dy}`];
        }
        function getRelativeCoords(playerX, playerY, playerFacingChar, targetX, targetY) {
            const worldDX = targetX - playerX; const worldDY = targetY - playerY;
            let pf;
            if (playerFacingChar === '^') pf = 'n'; else if (playerFacingChar === 'v') pf = 's';
            else if (playerFacingChar === '<') pf = 'w'; else if (playerFacingChar === '>') pf = 'e';
            else return { rx: worldDX, ry: worldDY }; // Should not happen with valid chars
            if (pf === 'n') return {rx: worldDX, ry: worldDY}; if (pf === 's') return {rx: -worldDX, ry: -worldDY};
            if (pf === 'w') return {rx: -worldDY, ry: worldDX}; if (pf === 'e') return {rx: worldDY, ry: -worldDX};
            return { rx: worldDX, ry: worldDY }; // Fallback
        }
        function manhattanDistance(x1, y1, x2, y2) { return Math.abs(x1 - x2) + Math.abs(y1 - y2); }

        function isVisible(observerX, observerY, observerChar, targetX, targetY, scry = false) {
            // This client-side isVisible is now mostly for immediate cosmetic effects or pre-emptive checks.
            // Server FOV is the source of truth for what's actually visible in game_update.
            if (!observerChar || !selfPlayer) return false;
            let manhattanDist = manhattanDistance(observerX, observerY, targetX, targetY);
            if (scry || manhattanDist <= AURA_VISION_RANGE) return true; // Aura/self always visible

            const {rx, ry} = getRelativeCoords(observerX, observerY, observerChar, targetX, targetY);
            const clientObservableDepth = 10; // How "deep" the client might guess visibility
            const OBSERVABLE_WIDTH_CONST = 1.0; // How "wide" the cone is

            // Simple cone based on player facing for client-side prediction/cosmetics
            if (ry < 0 && -ry <= clientObservableDepth && Math.abs(rx) <= Math.floor(-ry * OBSERVABLE_WIDTH_CONST )) return true;

            return false;
        }

        function addLogMessage(message, type = 'lore') {
            const logEntry = document.createElement('div');
            let displayStyle = 'ink';
            switch (type) {
                case 'event-bad': case 'chat-shout': case 'server-major-event':
                case 'player-trade': case 'player-damage': case 'welcome-message':
                case 'sensory-magic':
                    displayStyle = 'mana'; break;
                case 'sensory-sound': case 'sensory-smell': case 'sensory-sight':
                case 'system': case 'event-good': case 'spell-cast':
                case 'lore': case 'user-input': case 'chat-say':
                default: displayStyle = 'ink'; break;
            }
            logEntry.classList.add('log-entry', `log-style-${displayStyle}`, `log-type-${type}`);
            logEntry.textContent = message;
            commandLog.appendChild(logEntry);
            requestAnimationFrame(() => { commandLog.scrollTop = commandLog.scrollHeight; });
        }
        function logRandomizedEvent(mainKey, subKey, placeholders = {}, messageType = 'lore') {
            const message = getRandomGameText(mainKey, subKey, placeholders);
            addLogMessage(message, messageType);
        }

        function updateStatus() { // Main status bar update
            if (!selfPlayer) {
                mainHeaderStatus.textContent = "Connecting to the World of the Wand...";
                return;
            }
            let healthPercentage = selfPlayer.max_health > 0 ? Math.round((selfPlayer.current_health / selfPlayer.max_health) * 100) : 0;
            mainHeaderStatus.textContent = `${healthPercentage}% Health | ${selfPlayer.current_mana} Mana | ${selfPlayer.gold || 0} Gold | ${selfPlayer.potions} Potions | ${selfPlayer.walls} Walls`;

            // Update debug context if panel is visible
            if (showDebugInfoState) {
                dbgSceneCoords.textContent = `(${selfPlayer.scene_x},${selfPlayer.scene_y})`;
                // Scene name and type might need server data if dynamic, placeholder for now
                dbgSceneName.textContent = currentSceneData.name || "Unknown Realm"; // Placeholder
                dbgLocationType.textContent = currentSceneData.InsideID === 0 ? 'Outdoors' : `Indoors (ID:${currentSceneData.InsideID})`; // Placeholder
                dbgPlayerChar.textContent = selfPlayer.char;
                dbgPlayerCoords.textContent = `(${selfPlayer.x},${selfPlayer.y})`;
                dbgPlayerStatus.textContent = selfPlayer.is_wet ? 'Wet' : 'Dry';
            }
        }

        function estimateCharacterSize(context = "unknown") {
            const testChar = 'M';
            const computedStyle = getComputedStyle(document.documentElement);
            const fontFamily = computedStyle.getPropertyValue('--font-game').trim() || "'Courier New', monospace";
            const fontSize = DEFAULT_FONT_SIZE_PX + "px";
            const tempSpan = document.createElement('span');
            tempSpan.style.fontFamily = fontFamily; tempSpan.style.fontSize = fontSize;
            tempSpan.style.lineHeight = computedStyle.getPropertyValue('line-height') || String(DEFAULT_FONT_SIZE_PX * 0.9);
            tempSpan.style.whiteSpace = 'pre'; tempSpan.style.visibility = 'hidden'; tempSpan.style.position = 'absolute';
            tempSpan.textContent = testChar;
            document.body.appendChild(tempSpan);
            let measuredWidth = tempSpan.offsetWidth; let measuredHeight = tempSpan.offsetHeight;
            document.body.removeChild(tempSpan);

            if (measuredWidth > 0 && measuredHeight > 0) {
                charRenderWidth = measuredWidth * X_STRETCH_FACTOR; charRenderHeight = measuredHeight;
            } else {
                charRenderWidth = DEFAULT_CHAR_WIDTH_FALLBACK; charRenderHeight = DEFAULT_CHAR_HEIGHT_FALLBACK;
            }
            if (GRID_WIDTH > 0 && GRID_HEIGHT > 0 && charRenderWidth > 0 && charRenderHeight > 0) {
                gameCanvas.width = GRID_WIDTH * charRenderWidth; gameCanvas.height = GRID_HEIGHT * charRenderHeight;
            }
            charSizeEstimatedAtLeastOnce = true;
        }

        function drawGrid() {
            if (!ctx) return;
            if (!charSizeEstimatedAtLeastOnce || GRID_WIDTH === 0 || GRID_HEIGHT === 0 || gameCanvas.width === 0 || gameCanvas.height === 0) {
                // Fallback rendering if not ready (same as before)
                const canvasWidth = gameCanvas.width || (DEFAULT_CHAR_WIDTH_FALLBACK * GRID_WIDTH) || 300;
                const canvasHeight = gameCanvas.height || (DEFAULT_CHAR_HEIGHT_FALLBACK * GRID_HEIGHT) || 200;
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                const tempFont = "16px 'Courier New', monospace";
                const tempFill = getComputedStyle(document.body).getPropertyValue('--text-primary') || "#E2E8F0";
                ctx.font = tempFont; ctx.fillStyle = tempFill;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                const loadingBg = getComputedStyle(document.body).getPropertyValue('--bg-secondary') || '#2d3748';
                ctx.fillStyle = loadingBg; ctx.fillRect(0,0, canvasWidth, canvasHeight);
                ctx.fillStyle = tempFill;
                ctx.fillText("The mists obscure your vision...", canvasWidth / 2, canvasHeight / 2 - 10);
                ctx.fillText("(Awaiting server data or font readiness)", canvasWidth / 2, canvasHeight / 2 + 10);
                if (!charSizeEstimatedAtLeastOnce) estimateCharacterSize("drawGrid_fallback_estimate");
                return;
            }

            const bodyStyle = getComputedStyle(document.body);
            ctx.fillStyle = bodyStyle.getPropertyValue('--canvas-bg-consistent').trim();
            ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

            if (!selfPlayer) { // Still show a message if selfPlayer is missing after char estimation
                const tempFont = "16px 'Courier New', monospace";
                const tempFill = bodyStyle.getPropertyValue('--text-game-floor-consistent').trim() || "#9CA3AF";
                ctx.font = tempFont; ctx.fillStyle = tempFill;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText("(Awaiting player manifestation...)", gameCanvas.width / 2, gameCanvas.height / 2);
                return;
            }

            const gameFontFamily = bodyStyle.getPropertyValue('--font-game').trim() || "'Courier New', monospace";
            ctx.font = `${DEFAULT_FONT_SIZE_PX}px ${gameFontFamily}`;
            ctx.textBaseline = 'top'; ctx.textAlign = 'left';

            const floorColor = bodyStyle.getPropertyValue('--text-game-floor-consistent').trim();
            const wallColor = bodyStyle.getPropertyValue('--text-game-wall-consistent').trim();
            const waterColor = bodyStyle.getPropertyValue('--text-game-water-consistent').trim();
            const fogColor = bodyStyle.getPropertyValue('--text-game-fog-consistent').trim();
            const selfPlayerBaseColor = bodyStyle.getPropertyValue('--text-game-self-consistent').trim();
            const otherPlayerBaseColor = bodyStyle.getPropertyValue('--text-game-other-consistent').trim();
            const npcPixieColor = bodyStyle.getPropertyValue('--text-game-npc-pixie-consistent').trim();
            const wetPlayerTintColor = bodyStyle.getPropertyValue('--text-game-wet-tint-consistent').trim();

            // Server now sends only visible terrain based on its FOV
            // So, client iterates all grid cells, but only draws what's in visibleTerrain or defaults to fog.
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    let charToDraw = FOG_CHAR; // Default to fog
                    let colorToUse = fogColor;

                    // Check if this tile (x,y) is in the visible terrain data sent by server
                    const isWall = visibleTerrain.walls && visibleTerrain.walls.some(w => w.x === x && w.y === y);
                    const isWater = visibleTerrain.water && visibleTerrain.water.some(wt => wt.x === x && wt.y === y);

                    if (isWall) {
                        charToDraw = WALL_CHAR; colorToUse = wallColor;
                    } else if (isWater) {
                        charToDraw = WATER_CHAR; colorToUse = waterColor;
                    } else {
                        // If not wall or water, assume it's floor IF it's part of the visible area.
                        // The server should only send terrain tiles that are within the player's FOV.
                        // For tiles not explicitly in walls/water but within FOV, they are floor.
                        // For simplicity here, if it's not wall/water, we'll consider it floor for now if it's not fog.
                        // This implies client logic would need the full visible_tiles set from server to perfectly draw floor vs fog.
                        // For now, if it's not wall/water, and if we assume server has filtered non-visible,
                        // any non-wall/water tile *could* be floor.
                        // A more robust way: client also gets the set of visible (x,y) coords.
                        // For now, let's assume `visibleTerrain` only contains truly visible terrain.
                        // The "fog" is everything *else*. If a tile (x,y) is NOT in any visibleTerrain list,
                        // and not occupied by a visible player/NPC, it should be fog.
                        // If server only sends wall/water tiles that are visible, we need a way to know what else is visible (floor).
                        // The current server sends terrain based on player.visible_tiles_cache. So it's already filtered.
                        // Thus, if it's not wall or water from the payload, it must be visible floor.
                        
                        // Check if the current (x,y) is occupied by a visible player or NPC. If so, it's not fog.
                        // Otherwise, if not wall or water, it's floor.
                        let isOccupiedVisible = (selfPlayer.x === x && selfPlayer.y === y);
                        if (!isOccupiedVisible) {
                            for (const id in otherPlayers) if (otherPlayers[id].x === x && otherPlayers[id].y === y) isOccupiedVisible = true;
                        }
                        if (!isOccupiedVisible) {
                            visibleNPCs.forEach(npc => { if (npc.x === x && npc.y === y) isOccupiedVisible = true; });
                        }

                        if(isWall || isWater || isOccupiedVisible) {
                           // Already handled or will be by entity drawing
                        } else { // If not wall, water, or occupied by visible entity, assume it's visible floor from payload
                            charToDraw = FLOOR_CHAR; colorToUse = floorColor;
                        }
                    }
                    ctx.fillStyle = colorToUse;
                    ctx.fillText(charToDraw, x * charRenderWidth, y * charRenderHeight);
                }
            }


            if (visibleNPCs) { // NPCs are already filtered by server FOV
                visibleNPCs.forEach(npc => {
                    ctx.fillStyle = npcPixieColor;
                    ctx.fillText(npc.char || PIXIE_CHAR_CLIENT, npc.x * charRenderWidth, npc.y * charRenderHeight);
                });
            }

            for (const id in otherPlayers) { // Other players are already filtered by server FOV
                const p = otherPlayers[id];
                ctx.fillStyle = otherPlayerBaseColor;
                ctx.fillText(p.char, p.x * charRenderWidth, p.y * charRenderHeight);
                if (p.is_wet) {
                    ctx.fillStyle = wetPlayerTintColor;
                    ctx.fillRect(p.x * charRenderWidth, p.y * charRenderHeight, charRenderWidth, charRenderHeight);
                    ctx.fillStyle = otherPlayerBaseColor;
                    ctx.fillText(p.char, p.x * charRenderWidth, p.y * charRenderHeight);
                }
            }

            if (selfPlayer) { // Self player is always "visible" to self
                ctx.fillStyle = selfPlayerBaseColor;
                ctx.fillText(selfPlayer.char, selfPlayer.x * charRenderWidth, selfPlayer.y * charRenderHeight);
                if (selfPlayer.is_wet) {
                    ctx.fillStyle = wetPlayerTintColor;
                    ctx.fillRect(selfPlayer.x * charRenderWidth, selfPlayer.y * charRenderHeight, charRenderWidth, charRenderHeight);
                    ctx.fillStyle = selfPlayerBaseColor;
                    ctx.fillText(selfPlayer.char, selfPlayer.x * charRenderWidth, selfPlayer.y * charRenderHeight);
                }
            }
        }


        function startRainEffect(intensity) { /* ... same as before ... */ }
        function stopRainEffect() { /* ... same as before ... */ }
        function updateWeatherEffects() { /* ... same as before ... */ }
        gameCanvasContainer.addEventListener('mousedown', (e) => { /* ... same as before ... */ });
        window.addEventListener('mousemove', (e) => { /* ... same as before ... */ });
        window.addEventListener('mouseup', (e) => { /* ... same as before ... */ });
        gameCanvasContainer.addEventListener('mouseleave', () => { /* ... same as before ... */ });
        function centerViewOnPlayer(context = "unknown") { /* ... same as before ... */ }
        gameCanvasContainer.addEventListener('wheel', function(event) { /* ... same as before ... */ }, { passive: false });
        // Pinch zoom listeners ... same as before ...
        gameCanvasContainer.addEventListener('touchstart', function(event) { /* ... same as before ... */ }, { passive: false });
        gameCanvasContainer.addEventListener('touchmove', function(event) { /* ... same as before ... */ }, { passive: false });
        gameCanvasContainer.addEventListener('touchend', function(event) { /* ... same as before ... */ });


        debugInfoToggle.addEventListener('change', (event) => {
            showDebugInfoState = event.target.checked;
            localStorage.setItem('worldOfTheWandShowDebug', JSON.stringify(showDebugInfoState));

            if (showDebugInfoState) { // Show Debug Panel
                commandLog.style.display = 'none';
                debugAndAuxiliaryPanel.style.display = 'flex';
            } else { // Show Command Log
                commandLog.style.display = 'flex';
                debugAndAuxiliaryPanel.style.display = 'none';
            }
            updateStatus(); // Update status bar and potentially debug context
        });

        rainIntensitySlider.addEventListener('input', (event) => { /* ... same as before ... */ });
        simulateHeartbeatToggle.addEventListener('change', (event) => { /* ... same as before, ensure dbgSimulating updates ... */
            simulateServerHeartbeatEnabled = event.target.checked;
            localStorage.setItem('simulateServerHeartbeat', simulateServerHeartbeatEnabled);
            if(dbgSimulating) dbgSimulating.textContent = simulateServerHeartbeatEnabled;

            if (simulateServerHeartbeatEnabled) {
                if (simulatedHeartbeatInterval) clearInterval(simulatedHeartbeatInterval);
                simulatedHeartbeatInterval = setInterval(() => {
                    if (simulatedHeartbeatIndicator) {
                        simulatedHeartbeatIndicator.classList.add('heartbeat-flash');
                        if(simulatedHeartbeatFlashTimeout) clearTimeout(simulatedHeartbeatFlashTimeout);
                        simulatedHeartbeatFlashTimeout = setTimeout(() => { if(simulatedHeartbeatIndicator) simulatedHeartbeatIndicator.classList.remove('heartbeat-flash'); }, 150);
                    }
                    if (selfPlayer) { drawGrid(); } // Redraw on simulated tick
                    if(showDebugInfoState && dbgSimulating) { // Update debug text
                        dbgSimulating.textContent = `${simulateServerHeartbeatEnabled} (Last: ${new Date().toLocaleTimeString()})`;
                    }
                }, GAME_HEARTBEAT_RATE * 1000);
            } else {
                if (simulatedHeartbeatInterval) clearInterval(simulatedHeartbeatInterval);
                simulatedHeartbeatInterval = null;
            }
        });


        const resizeObserver = new ResizeObserver(entries => { /* ... same as before ... */ });
        if (gameCanvasContainer) resizeObserver.observe(gameCanvasContainer);

        function initializeUIDisplayStates() { /* ... same as before ... */ }


        socket.on('connect', () => { /* ... same as before ... */ });
        socket.on('connect_error', (err) => { /* ... same as before ... */ });
        socket.on('initial_game_data', (data) => { /* ... same as before, but updateStatus will handle new debug context elements ... */
            if (!data || !data.player_data ) { logRandomizedEvent('LORE', 'CORRUPT_MANIFESTATION_SERVER', {detail: "Data/player_data missing"}, 'event-bad'); if(ctx) { ctx.clearRect(0,0, gameCanvas.width || 300, gameCanvas.height || 200); ctx.fillText("Error: Initial data from server corrupted.", 10, 20); } return; }
            if (typeof data.grid_width !== 'number' || typeof data.grid_height !== 'number') { logRandomizedEvent('LORE', 'CORRUPT_MANIFESTATION_SERVER', {detail: "grid dimensions invalid"}, 'event-bad');}

            selfPlayer = data.player_data; myPlayerID = selfPlayer.id;
            GRID_WIDTH = data.grid_width || 20; GRID_HEIGHT = data.grid_height || 15;
            GAME_HEARTBEAT_RATE = data.tick_rate || 0.75;
            otherPlayers = {};
            visibleTerrain = data.visible_terrain || { walls: [], water: [] }; // Server now sends filtered terrain
            visibleNPCs = data.visible_npcs || [];
            currentSceneData.name = data.scene_name || "Unknown Realm"; // Assuming server might send this
            currentSceneData.InsideID = typeof data.is_indoors !== 'undefined' ? (data.is_indoors ? 1 : 0) : 0; // Assuming server might send this

            if (data.other_players_in_scene) { data.other_players_in_scene.forEach(p => { if (p.id !== myPlayerID) otherPlayers[p.id] = p; });}
            prevSelfPlayerState = { ...selfPlayer };

            initializeUIDisplayStates();

            if (!charSizeEstimatedAtLeastOnce) { estimateCharacterSize("initial_data_pre_font_ready"); }

            document.fonts.ready.then(() => {
                estimateCharacterSize("initial_data_fonts_ready");
                if (selfPlayer) {
                    drawGrid(); updateStatus();
                    if (gameCanvasContainer.clientHeight > 0 && !initialCenteringDone) {
                        centerViewOnPlayer("initial_data_direct_center_attempt");
                        initialCenteringDone = true;
                        if(!initialUIDone){
                             updateWeatherEffects();
                             logRandomizedEvent('LORE', 'WELCOME_INITIAL', {}, 'welcome-message');
                             if(showDebugInfoState && myPlayerID) logRandomizedEvent('LORE', 'WELCOME', { playerId: myPlayerID }, 'welcome-message');
                             if (currentSceneData.InsideID === 0 && globalWeather.isRaining) logRandomizedEvent('LORE', 'INITIAL_RAIN', {}, 'system');
                             initialUIDone = true;
                        }
                    } // ... (rest of centering logic same as before)
                } else { logRandomizedEvent('LORE', 'MANIFESTATION_FAILED_NO_PLAYER_DATA', {}, 'event-bad'); }
            }).catch(err => { /* ... same as before ... */ });
        });
        socket.on('player_entered_your_scene', (newPlayerData) => { /* ... same as before ... */ });
        socket.on('player_exited_your_scene', (exitedPlayerData) => { /* ... same as before ... */ });
        socket.on('lore_message', (data) => { /* ... same as before ... */ });
        socket.on('chat_message', (data) => { /* ... same as before ... */ });
        socket.on('player_event', (data) => { /* ... same as before ... */ });

        socket.on('game_update', (data) => {
             if (!selfPlayer || !myPlayerID || !data.self_player_data) { return; }
            if(dbgLastUpdate) dbgLastUpdate.textContent = new Date().toLocaleTimeString();
            if(serverHeartbeatIndicator && !simulateServerHeartbeatEnabled) {
                serverHeartbeatIndicator.classList.add('heartbeat-flash');
                if(serverHeartbeatFlashTimeout) clearTimeout(serverHeartbeatFlashTimeout);
                serverHeartbeatFlashTimeout = setTimeout(() => { if(serverHeartbeatIndicator) serverHeartbeatIndicator.classList.remove('heartbeat-flash'); }, 150);
            }

            selfPlayer = data.self_player_data;
            otherPlayers = {};
            if(data.visible_other_players) data.visible_other_players.forEach(p => { if (p.id !== myPlayerID) otherPlayers[p.id] = p; });
            visibleTerrain = data.visible_terrain || { walls: [], water: [] }; // Expecting server-filtered terrain
            visibleNPCs = data.visible_npcs || [];
            // Update scene context if provided by server (optional for now)
            currentSceneData.name = data.scene_name || currentSceneData.name;
            currentSceneData.InsideID = typeof data.is_indoors !== 'undefined' ? (data.is_indoors ? 1 : 0) : currentSceneData.InsideID;


            updateStatus(); // This will also update the debug context section
            if(showDebugInfoState && dbgSelfPlayer) {
                dbgSelfPlayer.textContent = `(${selfPlayer.x},${selfPlayer.y}) ${selfPlayer.char}`; // Wet status moved to context
                dbgOtherPlayersCount.textContent = Object.keys(otherPlayers).length;
                dbgNpcsCount.textContent = visibleNPCs.length;
            }

            prevSelfPlayerState = { ...selfPlayer };
            drawGrid();
            if (!charSizeEstimatedAtLeastOnce && GRID_WIDTH > 0 && GRID_HEIGHT > 0) { estimateCharacterSize("game_update_reestimate"); if(!isDragging) centerViewOnPlayer("game_update_after_reestimate_centering");}
            updateWeatherEffects();
        });
        function getDirectionWord(char) { /* ... same as before ... */ }
        socket.on('action_feedback', (data) => { /* ... same as before ... */ });
        socket.on('disconnect', (reason) => { /* ... same as before ... */ });

        // ACTION_ALIASES and DIRECTION_ALIASES ... same as before ...
        // parseAction and parseDirection functions ... same as before ...
        // commandInput keydown listener ... same as before ...
        // commandForm submit listener ... same as before ...

        window.toggleRainDebug = function() { /* ... same as before ... */ };
        window.toggleInsideDebug = function() { /* ... same as before ... */ };

        document.addEventListener('DOMContentLoaded', () => { /* ... same as before, calls initializeUIDisplayStates ... */
            initializeTheme();
            initializeUIDisplayStates();
            estimateCharacterSize("dom_content_loaded");
            drawGrid();
            updateStatus("Awaiting connection to the Ethereal Plane...");
            updateWeatherEffects();
            logRandomizedEvent('LORE', 'WELCOME_INITIAL', {}, 'welcome-message');
            if (commandInput) { commandInput.focus(); }
        });

    </script>
</body>
</html>