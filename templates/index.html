<!DOCTYPE html>
<html lang = "en">
<head>
    <meta charset = "UTF-8">
    <meta name = "viewport" content = "width = device-width, initial-scale = 1.0">
    <title>World of the Wand - Tome of Echoes</title>
    <link rel = "stylesheet" href = "{{url_for('game.static', filename = 'style.css')}}">

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
        const socket = io({path: "/world-of-the-wand/socket.io"});
    </script>
</head>
<body>
    <div class="main-ui-container">
        <div class="left-panel">
            <div id="commandLog"></div>
        </div>

        <div class="right-panel">
            <div id="mainHeaderStatus">Pondering the Ethereal Wave...</div>

            <div class="game-area-flex-container">
                <div id="gameCanvasContainer">
                    <div id="gameCanvas">Summoning World...</div>
                    <div id="rainOverlay"></div>
                </div>
                <div id="healthHelixContainer">
                    <div class="health-label">Vitality</div>
                    <canvas id="healthHelixCanvas"></canvas>
                </div>
            </div>

            <div id="commandInputBox">
                <form id="commandForm">
                    <label for="commandText">Inscribe Thy Will:</label>
                    <div id="commandText" contenteditable="true" spellcheck="false" autocomplete="off" role="textbox" aria-multiline="false"></div>
                    <button type="submit">Commit</button>
                </form>
            </div>
        </div>
    </div>

    <script>
        const gameCanvas = document.getElementById('gameCanvas');
        const gameCanvasContainer = document.getElementById('gameCanvasContainer');
        const rainOverlay = document.getElementById('rainOverlay');
        const mainHeaderStatus = document.getElementById('mainHeaderStatus');
        const commandLog = document.getElementById('commandLog');
        const commandForm = document.getElementById('commandForm');
        const commandInput = document.getElementById('commandText');

        // Health Helix Elements
        const healthHelixContainer = document.getElementById('healthHelixContainer');
        const healthHelixCanvas = document.getElementById('healthHelixCanvas');
        const helixCtx = healthHelixCanvas.getContext('2d');
        let helixAnimationId = null;
        let helixPhase = 0;


        let selfPlayer = null;
        let otherPlayers = {};
        let myPlayerID = null;
        let GRID_WIDTH = 40;
        let GRID_HEIGHT = 20;
        let GAME_TICK_RATE = 1.0;
        let prevSelfPlayerState = null;

        let currentSceneData = {
            InsideID: 0, 
            name: "The Whispering Plains" 
        };
        let globalWeather = {
            isRaining: false,
            intensity: 0.6 
        };
        let rainInterval = null;


        const FOG_CHAR = '░'; 
        const FLOOR_CHAR = '·'; 
        const OBSERVABLE_DEPTH = 7;
        const OBSERVABLE_WIDTH = 1.0;
        const AURA_VISION_RANGE = 1;

        // --- Health Helix Functions ---
        function resizeHealthHelixCanvas() {
            // Set canvas internal resolution to match its display size
            healthHelixCanvas.width = healthHelixContainer.clientWidth -10; // Account for padding
            healthHelixCanvas.height = healthHelixContainer.clientHeight - 30; // Account for padding & label
             // If in mobile view (horizontal bar)
            if (window.innerWidth <= 800) {
                healthHelixCanvas.width = healthHelixContainer.clientWidth - document.querySelector('.health-label').offsetWidth - 20;
                healthHelixCanvas.height = healthHelixContainer.clientHeight - 10;
            }
        }

        function getHealthColor(percent) {
            // Clamp percent between 0 and 1
            percent = Math.max(0, Math.min(1, percent));

            let r, g, b;
            // Red (0%) -> Yellow (50%) -> Green (75%) -> Blue (100%)
            if (percent < 0.5) { // Red to Yellow
                r = 255;
                g = Math.round(255 * (percent * 2)); // 0 at 0%, 255 at 50%
                b = 0;
            } else if (percent < 0.75) { // Yellow to Green
                r = Math.round(255 * (1 - (percent - 0.5) * 4)); // 255 at 50%, 0 at 75%
                g = 255;
                b = 0;
            } else { // Green to Blue/Cyan
                r = 0;
                g = Math.round(255 * (1 - (percent - 0.75) * 4)); // 255 at 75%, 0 at 100%
                b = Math.round(255 * ((percent - 0.75) * 4));      // 0 at 75%, 255 at 100% (making it cyan-ish blue)
                 // For a more distinct blue at high health:
                // b = 150 + Math.round(105 * ((percent - 0.75) * 4)); 
            }
            return `rgb(${r},${g},${b})`;
        }


        function drawHealthHelix() {
            if (!selfPlayer || typeof selfPlayer.current_health === 'undefined') {
                helixCtx.clearRect(0, 0, healthHelixCanvas.width, healthHelixCanvas.height);
                helixCtx.fillStyle = 'grey';
                helixCtx.font = '10px var(--font-ui)';
                helixCtx.textAlign = 'center';
                // helixCtx.fillText('No Data', healthHelixCanvas.width / 2, healthHelixCanvas.height / 2);
                return;
            }

            const width = healthHelixCanvas.width;
            const height = healthHelixCanvas.height;
            helixCtx.clearRect(0, 0, width, height);

            const healthPercent = selfPlayer.max_health > 0 ? selfPlayer.current_health / selfPlayer.max_health : 0;
            const color = getHealthColor(healthPercent);

            const amplitude = width * 0.3; // Amplitude based on canvas width
            const frequency = (Math.PI * 2) / (height * 0.7); // How many waves fit vertically
            const lineWidth = Math.max(2, Math.min(8, width * 0.08)); // Dynamic line width

            helixCtx.strokeStyle = color;
            helixCtx.lineWidth = lineWidth;
            helixCtx.lineCap = 'round';

            // Animate fill height
            const fillHeight = height * healthPercent;

            // Draw two sine waves
            for (let i = 0; i < 2; i++) { // Two strands
                helixCtx.beginPath();
                const phaseOffset = i * Math.PI; // Offset second strand by 180 degrees
                let firstPoint = true;

                for (let y = 0; y <= height; y++) {
                    const xPos = (width / 2) + amplitude * Math.sin(frequency * y + helixPhase + phaseOffset);
                    if (firstPoint) {
                        helixCtx.moveTo(xPos, y);
                        firstPoint = false;
                    } else {
                        helixCtx.lineTo(xPos, y);
                    }
                }
                helixCtx.stroke();
            }
            
            // Glow effect (optional, can be performance intensive)
            helixCtx.shadowBlur = 10;
            helixCtx.shadowColor = color;
            // Redraw for glow to take effect (draw on top of itself)
             for (let i = 0; i < 2; i++) { 
                helixCtx.beginPath();
                const phaseOffset = i * Math.PI; 
                let firstPoint = true;
                for (let y = 0; y <= height; y++) {
                    const xPos = (width / 2) + amplitude * Math.sin(frequency * y + helixPhase + phaseOffset);
                    if (firstPoint) { helixCtx.moveTo(xPos, y); firstPoint = false; } 
                    else { helixCtx.lineTo(xPos, y); }
                }
                helixCtx.stroke();
            }
            helixCtx.shadowBlur = 0; // Reset shadow

            // Clipping mask for the "filling" effect (apply to the already drawn helix)
            // This is more complex with two interwoven strands.
            // A simpler visual might be to just color the strands based on health and let the animation be the main dynamic part.
            // Or, draw the "empty" part of the helix in a dimmer color.

            // For now, the color of the strands IS the health indicator.
        }
        
        function animateHelix() {
            helixPhase += 0.03; // Speed of the barber pole effect
            if (helixPhase > Math.PI * 2) {
                helixPhase -= Math.PI * 2;
            }
            drawHealthHelix();
            helixAnimationId = requestAnimationFrame(animateHelix);
        }

        function stopHelixAnimation() {
            if (helixAnimationId) {
                cancelAnimationFrame(helixAnimationId);
                helixAnimationId = null;
            }
        }
        // --- End Health Helix Functions ---


        function get_dx_dy_from_direction_str(s) { /* ... */ }
        function get_direction_str_from_dx_dy(dx, dy) { /* ... */ }
        function getRelativeCoords(playerX, playerY, playerFacingChar, targetX, targetY) { /* ... */ }
        function manhattanDistance(x1, y1, x2, y2) { /* ... */ }
        function isVisible(observerX, observerY, observerChar, targetX, targetY, scry = false) { /* ... */ }

        function addLogMessage(message, type = 'lore') {
            const logEntry = document.createElement('div');
            let displayStyle = 'ink'; 
            switch (type) {
                case 'system':
                case 'event-good':
                case 'event-bad':
                case 'spell-cast': 
                    displayStyle = 'mana';
                    break;
                case 'lore':
                case 'user-input':
                default:
                    displayStyle = 'ink';
                    break;
            }
            logEntry.classList.add('log-entry', `log-style-${displayStyle}`, `log-type-${type}`);
            logEntry.textContent = message;
            commandLog.appendChild(logEntry);
            requestAnimationFrame(() => { commandLog.scrollTop = commandLog.scrollHeight; });
        }

        function updateStatus(status) {
            if (status) {
                mainHeaderStatus.textContent = status;
            } else if (selfPlayer) {
                let locationType = currentSceneData.InsideID === 0 ? 'Outdoors' : `Indoors (Sector ${currentSceneData.InsideID})`;
                let healthInfo = (typeof selfPlayer.current_health !== 'undefined') ? `${selfPlayer.current_health}/${selfPlayer.max_health} HP` : "HP ?";
                let manaInfo = (typeof selfPlayer.current_mana !== 'undefined') ? `${selfPlayer.current_mana}/${selfPlayer.max_mana} MP` : "MP ?";
                let potionsInfo = (typeof selfPlayer.potions !== 'undefined') ? `${selfPlayer.potions} Potions` : "Potions ?";
                
                mainHeaderStatus.textContent = `Scene: (${selfPlayer.scene_x}, ${selfPlayer.scene_y}) ${currentSceneData.name} [${locationType}] | ${selfPlayer.char}: (${selfPlayer.x}, ${selfPlayer.y}) | ${healthInfo} | ${manaInfo} | ${potionsInfo} | Wand: 100%`;
            } else {
                mainHeaderStatus.textContent = "Awaiting Your Manifestation...";
            }
        }

        function drawGrid() { /* ... */ }
        function startRainEffect(intensity) { /* ... */ }
        function stopRainEffect() { /* ... */ }
        function updateWeatherEffects() { /* ... */ }

        socket.on('connect', () => { /* ... */ });

        socket.on('initial_state', (data) => {
            selfPlayer = data.player;
            myPlayerID = selfPlayer.id;
            GRID_WIDTH = data.grid_width;
            GRID_HEIGHT = data.grid_height;
            GAME_TICK_RATE = data.tick_rate;
            otherPlayers = data.other_players || {};
            prevSelfPlayerState = { ...selfPlayer };

            if (otherPlayers[myPlayerID]) delete otherPlayers[myPlayerID];

            if (selfPlayer && typeof GRID_WIDTH === 'number' && GRID_WIDTH > 0) {
                resizeHealthHelixCanvas(); // Resize canvas before first draw
                if (!helixAnimationId) animateHelix(); // Start animation
                drawHealthHelix(); // Initial draw
                updateStatus();
                drawGrid(); 
                updateWeatherEffects(); 
                addLogMessage(`Tome: You have materialized in ${currentSceneData.name} at scene (${selfPlayer.scene_x}, ${selfPlayer.scene_y}). The world awaits!`, 'lore');
                 if (currentSceneData.InsideID === 0 && globalWeather.isRaining) {
                    addLogMessage("Tome notes: A chilling rain falls from the slate-grey sky.", "system");
                }
            } else {
                addLogMessage("Tome warns: Error! Could not manifest in world.", 'event-bad');
            }
        });

        socket.on('player_joined', (newPlayer) => { /* ... */ });
        socket.on('player_left', (playerID) => { /* ... */ });
        socket.on('lore_message', (data) => { /* ... */ });
        socket.on('weather_update', (weatherData) => { /* ... */ });
        socket.on('scene_data_update', (sceneData) => { /* ... */ });

        socket.on('game_state_update', (allPlayers) => {
            let foundSelf = false;
            const currentOtherPlayersInMyScene = {};
            
            for (const playerData of allPlayers) {
                if (playerData.id === myPlayerID) {
                    // Update selfPlayer, including health for the helix
                    const oldHealth = selfPlayer ? selfPlayer.current_health : null;
                    selfPlayer = playerData;
                    if (oldHealth !== selfPlayer.current_health) {
                        drawHealthHelix(); // Redraw helix if health changed
                    }
                    foundSelf = true;
                } else if (selfPlayer && playerData.scene_x === selfPlayer.scene_x && playerData.scene_y === selfPlayer.scene_y) {
                    currentOtherPlayersInMyScene[playerData.id] = playerData;
                }
            }
            otherPlayers = currentOtherPlayersInMyScene;

            if (!foundSelf && myPlayerID) { /* ... */ }

            if (selfPlayer && prevSelfPlayerState) {
                const sceneCoordsChanged = selfPlayer.scene_x !== prevSelfPlayerState.scene_x || selfPlayer.scene_y !== prevSelfPlayerState.scene_y;
                if (sceneCoordsChanged) { /* ... */ } else { /* ... local move/turn logging ... */ }
            }
            if (selfPlayer) prevSelfPlayerState = { ...selfPlayer };
            
            drawGrid();
            updateStatus(); 
            updateWeatherEffects(); 
        });

        function getDirectionWord(char) { /* ... */ }
        socket.on('action_queued', (data) => { /* ... */ });
        socket.on('action_failed', (data) => { /* ... */ });
        socket.on('disconnect', () => { 
            /* ... */
            stopHelixAnimation(); 
            /* ... */ 
        });

        const ACTION_ALIASES = {
            "move": ["move", "go", "walk", "step", "head", "run"],
            "look": ["look", "face", "turn"],
            "cast": ["cast", "zap", "fire", "spell"],
            "drink": ["drink", "quaff", "use"], // Added "drink" aliases
            "help": ["help", "?"]
        };
        const DIRECTION_ALIASES = { /* ... */ };
        function parseAction(actionWord) { /* ... */ }
        function parseDirection(directionStr, curFacing) { /* ... */ }

        commandInput.addEventListener('keydown', (event) => { /* ... */ });

        commandForm.addEventListener('submit', (event) => {
            event.preventDefault();
            if (!selfPlayer) { /* ... */ return; }
            const inputText = commandInput.textContent.trim();
            commandInput.innerHTML = '';

            if (!inputText) return;
            addLogMessage(`> ${inputText}`, 'user-input');

            const parts = inputText.split(/\s+/);
            let actionWord = parts[0];
            let targetWord = parts.length > 1 ? parts.slice(1).join(' ') : null;

            // Handle "drink potion" type commands, normalize to "drink"
            if ((actionWord.toLowerCase() === "drink" || actionWord.toLowerCase() === "use") && targetWord && (targetWord.toLowerCase().includes("potion") || targetWord.toLowerCase().includes("flask"))) {
                // Action is "drink", target is already potion-related, effectively no target needed for server
                targetWord = null; 
            } else if (actionWord.toLowerCase() === "quaff" && (!targetWord || targetWord.toLowerCase().includes("potion"))) {
                 targetWord = null; // "quaff" implies potion
            }


            const canonicalAction = parseAction(actionWord);

            if (!canonicalAction) { /* ... */ return; }

            let commandToSend = { type: canonicalAction, details: {} };
            let shouldEmit = false;

            if (canonicalAction === "move") { /* ... */ } 
            else if (canonicalAction === "look") { /* ... */ } 
            else if (canonicalAction === "help") { /* ... */ } 
            else if (canonicalAction === "cast") { /* ... */ }
            else if (canonicalAction === "drink") {
                commandToSend.type = 'drink_potion'; // Server expects this specific type
                // No details needed as per spec (you always drink an unknown potion from your stack)
                shouldEmit = true;
                addLogMessage("Tome observes: You reach for a potion...", 'system');
            }
            else { /* ... default error ... */ }

            if (shouldEmit) {
                socket.emit('queue_command', commandToSend);
            }
            commandInput.focus();
        });
        
        window.toggleRainDebug = function() { /* ... */ };
        window.toggleInsideDebug = function() { /* ... */ };
        window.addEventListener('resize', resizeHealthHelixCanvas); // Resize canvas on window resize

        // Initial setup
        drawGrid();
        if (commandInput) { commandInput.focus(); }
        updateWeatherEffects();
        // Start animation after initial_state is processed and canvas can be sized
        // resizeHealthHelixCanvas(); // Initial size
        // animateHelix(); // Start animation moved to initial_state

        addLogMessage("Tome unfurls its pages: Welcome, Wizard. The Ethereal Waves await your command.", 'system');

    </script>
</body>
</html>