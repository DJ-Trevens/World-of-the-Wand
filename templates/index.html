<!DOCTYPE html>
<html lang = "en">
<head>
    <meta charset = "UTF-8">
    <meta name = "viewport" content = "width = device-width, initial-scale = 1.0">
    <title>World of the Wand - Tome of Echoes</title>
    <link rel = "stylesheet" href = "{{url_for('game.static', filename = 'style.css')}}">

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
        const socket = io({path: "/world-of-the-wand/socket.io"});
    </script>
</head>
<body>
    <div class="main-ui-container">
        <div class="left-panel">
            <div id="commandLog"></div>
        </div>

        <div class="right-panel">
            <div id="mainHeaderStatus">Pondering the Ethereal Wave...</div>

            <div class="game-area-flex-container"> {/* Simplified container */}
                <div id="gameCanvasContainer">
                    <div id="gameCanvas">Summoning World...</div>
                    <div id="rainOverlay"></div>
                </div>
                {/* Health Helix Removed Here */}
            </div>

            <div id="commandInputBox">
                <form id="commandForm">
                    <label for="commandText">Inscribe Thy Will:</label>
                    <div id="commandText" contenteditable="true" spellcheck="false" autocomplete="off" role="textbox" aria-multiline="false"></div>
                    <button type="submit">Commit</button>
                </form>
            </div>
        </div>
    </div>

    <script>
        const gameCanvas = document.getElementById('gameCanvas');
        const gameCanvasContainer = document.getElementById('gameCanvasContainer');
        const rainOverlay = document.getElementById('rainOverlay');
        const mainHeaderStatus = document.getElementById('mainHeaderStatus');
        const commandLog = document.getElementById('commandLog');
        const commandForm = document.getElementById('commandForm');
        const commandInput = document.getElementById('commandText');

        // Health Helix JS Removed

        let selfPlayer = null;
        let otherPlayers = {};
        let myPlayerID = null;
        let GRID_WIDTH = 40; // Will be updated by server
        let GRID_HEIGHT = 20; // Will be updated by server
        let GAME_TICK_RATE = 1.0; // Will be updated by server
        let prevSelfPlayerState = null;

        let currentSceneData = {
            InsideID: 0, 
            name: "The Whispering Plains" 
        };
        let globalWeather = {
            isRaining: false,
            intensity: 0.6 
        };
        let rainInterval = null;

        const FOG_CHAR = '░'; 
        const FLOOR_CHAR = '·'; 
        const OBSERVABLE_DEPTH = 7;
        const OBSERVABLE_WIDTH = 1.0;
        const AURA_VISION_RANGE = 1;

        function get_dx_dy_from_direction_str(s) { /* ... */ }
        function get_direction_str_from_dx_dy(dx, dy) { /* ... */ }
        function getRelativeCoords(playerX, playerY, playerFacingChar, targetX, targetY) { /* ... */ }
        function manhattanDistance(x1, y1, x2, y2) { /* ... */ }
        function isVisible(observerX, observerY, observerChar, targetX, targetY, scry = false) { /* ... */ }

        function addLogMessage(message, type = 'lore') {
            const logEntry = document.createElement('div');
            let displayStyle = 'ink'; 
            switch (type) {
                case 'system':
                case 'event-good':
                case 'event-bad':
                case 'spell-cast': 
                case 'chat-shout': // Shouts are mana based
                    displayStyle = 'mana';
                    break;
                case 'lore':
                case 'user-input':
                case 'chat-say': // Says are normal ink
                default:
                    displayStyle = 'ink';
                    break;
            }
            logEntry.classList.add('log-entry', `log-style-${displayStyle}`, `log-type-${type}`);
            logEntry.textContent = message;
            commandLog.appendChild(logEntry);
            requestAnimationFrame(() => { commandLog.scrollTop = commandLog.scrollHeight; });
        }

        function updateStatus(status) {
            if (status) {
                mainHeaderStatus.textContent = status;
            } else if (selfPlayer) {
                let locationType = currentSceneData.InsideID === 0 ? 'Outdoors' : `Indoors (Sector ${currentSceneData.InsideID})`;
                let healthInfo = (typeof selfPlayer.current_health !== 'undefined') ? `${selfPlayer.current_health}/${selfPlayer.max_health} HP` : "HP ?";
                let manaInfo = (typeof selfPlayer.current_mana !== 'undefined') ? `${selfPlayer.current_mana}/${selfPlayer.max_mana} MP` : "MP ?";
                let potionsInfo = (typeof selfPlayer.potions !== 'undefined') ? `${selfPlayer.potions} Potions` : "Potions ?";
                
                mainHeaderStatus.textContent = `Scene: (${selfPlayer.scene_x}, ${selfPlayer.scene_y}) ${currentSceneData.name} [${locationType}] | ${selfPlayer.char}: (${selfPlayer.x}, ${selfPlayer.y}) | ${healthInfo} | ${manaInfo} | ${potionsInfo} | Wand: 100%`;
            } else {
                mainHeaderStatus.textContent = "Awaiting Your Manifestation...";
            }
        }

        function drawGrid() { /* ... (unchanged from previous full file) ... */ }
        function startRainEffect(intensity) { /* ... (unchanged from previous full file) ... */ }
        function stopRainEffect() { /* ... (unchanged from previous full file) ... */ }
        function updateWeatherEffects() { /* ... (unchanged from previous full file) ... */ }

        socket.on('connect', () => { updateStatus("Divining your essence..."); });

        socket.on('initial_state', (data) => {
            selfPlayer = data.player;
            myPlayerID = selfPlayer.id;
            GRID_WIDTH = data.grid_width; // Set by server
            GRID_HEIGHT = data.grid_height; // Set by server
            GAME_TICK_RATE = data.tick_rate; // Set by server
            otherPlayers = data.other_players || {};
            prevSelfPlayerState = { ...selfPlayer };

            if (otherPlayers[myPlayerID]) delete otherPlayers[myPlayerID];

            if (selfPlayer && typeof GRID_WIDTH === 'number' && GRID_WIDTH > 0) {
                updateStatus();
                drawGrid(); 
                updateWeatherEffects(); 
                addLogMessage(`Tome: You have materialized in ${currentSceneData.name} at scene (${selfPlayer.scene_x}, ${selfPlayer.scene_y}). The world awaits!`, 'lore');
                 if (currentSceneData.InsideID === 0 && globalWeather.isRaining) {
                    addLogMessage("Tome notes: A chilling rain falls from the slate-grey sky.", "system");
                }
            } else {
                addLogMessage("Tome warns: Error! Could not manifest in world.", 'event-bad');
            }
        });

        socket.on('player_joined', (newPlayerData) => { // Expecting object now
            if (myPlayerID && newPlayerData.id !== myPlayerID && selfPlayer &&
                newPlayerData.scene_x === selfPlayer.scene_x && newPlayerData.scene_y === selfPlayer.scene_y) {
                otherPlayers[newPlayerData.id] = newPlayerData; // Store full new player data
                drawGrid();
                addLogMessage(`Tome notes: ${newPlayerData.name || 'A new sorcerer'} arrives in this area.`, 'event-good');
            }
        });
        socket.on('player_left', (playerID) => { /* ... (unchanged) ... */ });
        socket.on('lore_message', (data) => { /* ... (unchanged) ... */ });
        socket.on('weather_update', (weatherData) => { /* ... (unchanged) ... */ });
        socket.on('scene_data_update', (sceneData) => { /* ... (unchanged) ... */ });

        socket.on('chat_message', (data) => {
            // data = { sender_name: 'WizardName', message: 'Hello world!', type: 'say'/'shout' }
            let prefix = "";
            let messageType = 'chat-say'; // Default for styling
            if (data.type === 'shout') {
                prefix = `[SHOUT from ${data.sender_name || 'A distant voice'}]: `;
                messageType = 'chat-shout';
            } else { // say
                prefix = `[${data.sender_name || 'Someone nearby'} says]: `;
            }
            addLogMessage(prefix + data.message, messageType);
        });

        socket.on('game_state_update', (allPlayers) => {
            let foundSelf = false;
            const currentOtherPlayersInMyScene = {};
            
            for (const playerData of allPlayers) {
                if (playerData.id === myPlayerID) {
                    selfPlayer = playerData;
                    foundSelf = true;
                } else if (selfPlayer && playerData.scene_x === selfPlayer.scene_x && playerData.scene_y === selfPlayer.scene_y) {
                    currentOtherPlayersInMyScene[playerData.id] = playerData;
                }
            }
            otherPlayers = currentOtherPlayersInMyScene;

            if (!foundSelf && myPlayerID) { /* ... */ }

            if (selfPlayer && prevSelfPlayerState) {
                const sceneCoordsChanged = selfPlayer.scene_x !== prevSelfPlayerState.scene_x || selfPlayer.scene_y !== prevSelfPlayerState.scene_y;
                if (sceneCoordsChanged) { /* ... */ } else { /* ... local move/turn logging ... */ }
            }
            if (selfPlayer) prevSelfPlayerState = { ...selfPlayer };
            
            drawGrid();
            updateStatus(); 
            updateWeatherEffects(); 
        });

        function getDirectionWord(char) { /* ... (unchanged) ... */ }
        socket.on('action_queued', (data) => { /* ... (unchanged) ... */ });
        socket.on('action_failed', (data) => { /* ... (unchanged) ... */ });
        socket.on('disconnect', () => { /* ... (unchanged) ... */ });

        const ACTION_ALIASES = {
            "move": ["move", "go", "walk", "step", "head", "run"],
            "look": ["look", "face", "turn"],
            "cast": ["cast", "zap", "fire", "spell"],
            "drink": ["drink", "quaff", "use"],
            "say": ["say", "tell", "whisper", "'"], // Added ' as a say alias
            "shout": ["shout", "yell", "scream", "!"], // Added ! as a shout alias
            "help": ["help", "?"]
        };
        const DIRECTION_ALIASES = { /* ... (unchanged) ... */ };
        function parseAction(actionWord) { /* ... (unchanged) ... */ }
        function parseDirection(directionStr, curFacing) { /* ... (unchanged) ... */ }

        commandInput.addEventListener('keydown', (event) => { /* ... (unchanged) ... */ });

        commandForm.addEventListener('submit', (event) => {
            event.preventDefault();
            if (!selfPlayer) { /* ... */ return; }
            const inputText = commandInput.textContent.trim();
            commandInput.innerHTML = '';

            if (!inputText) return;
            
            const parts = inputText.split(/\s+/);
            let actionWord = parts[0];
            let messageContent = parts.length > 1 ? parts.slice(1).join(' ') : null; // Generic term for content after action word

            // Handle potential shorthand chat commands like ' message or ! message
            if (actionWord.startsWith("'")) {
                messageContent = (actionWord.substring(1) + (messageContent ? " " + messageContent : "")).trim();
                actionWord = "say";
            } else if (actionWord.startsWith("!")) {
                 messageContent = (actionWord.substring(1) + (messageContent ? " " + messageContent : "")).trim();
                actionWord = "shout";
            }

            addLogMessage(`> ${actionWord}${messageContent ? ' ' + messageContent : ''}`, 'user-input'); // Log the possibly transformed command

            const canonicalAction = parseAction(actionWord);

            if (!canonicalAction) {
                addLogMessage(`Tome seems puzzled: Your will "${actionWord}" is indecipherable.`, 'event-bad');
                commandInput.focus(); return;
            }

            let commandToSend = { type: canonicalAction, details: {} };
            let shouldEmit = false;

            if (canonicalAction === "move") { /* ... (unchanged logic but using messageContent for targetWord) ... */
                const effectiveTargetWord = messageContent || "forward";
                const dirResult = parseDirection(effectiveTargetWord, selfPlayer.char);
                if (dirResult.isValid) {
                    /* ... set commandToSend.details and shouldEmit = true ... */
                } else { /* ... error log ... */ }
            } else if (canonicalAction === "look") { /* ... (unchanged logic but using messageContent for targetWord) ... */
                 const effectiveTargetWord = messageContent || "forward";
                const dirResult = parseDirection(effectiveTargetWord, selfPlayer.char);
                if (dirResult.isValid) {
                    /* ... set commandToSend.details and shouldEmit = true ... */
                } else { /* ... error log ... */ }
            } else if (canonicalAction === "help") { /* ... (unchanged) ... */ 
            } else if (canonicalAction === "cast") { /* ... (unchanged logic but using messageContent for targetWord) ... */
                 if (messageContent) {
                    commandToSend.details = { spellName: messageContent }; 
                    shouldEmit = true;
                    addLogMessage(`Tome focuses: You begin to channel energy for "${messageContent}"...`, 'spell-cast');
                 } else { /* ... error log ... */ }
            } else if (canonicalAction === "drink") {
                // "drink" and "drink potion" are now normalized server-side expecting 'drink_potion'
                if (messageContent && (messageContent.toLowerCase().includes("potion") || messageContent.toLowerCase().includes("flask"))) {
                    // if user types "drink potion", it's fine.
                } else if (messageContent) { // User typed "drink something_else"
                    addLogMessage(`Tome queries: Drink what specifically? If a potion, just 'drink' or 'drink potion'.`, 'event-bad');
                    commandInput.focus();
                    return; // Don't proceed
                }
                // If no messageContent or it was "potion", proceed
                commandToSend.type = 'drink_potion';
                shouldEmit = true;
                addLogMessage("Tome observes: You reach for a potion...", 'system');
            } else if (canonicalAction === "say" || canonicalAction === "shout") {
                if (messageContent && messageContent.length > 0) {
                    commandToSend.details = { message: messageContent };
                    shouldEmit = true;
                    // Client-side feedback for queuing the chat
                    if(canonicalAction === "say") addLogMessage("Tome prepares to relay your words...", 'system');
                    else addLogMessage("Tome prepares to project your voice...", 'system');
                } else {
                    addLogMessage(`Tome asks: ${canonicalAction.charAt(0).toUpperCase() + canonicalAction.slice(1)} what, O Wizard? Your words are lost to the ether.`, 'event-bad');
                }
            }
            else { /* ... default error ... */ }

            if (shouldEmit) {
                socket.emit('queue_command', commandToSend);
            }
            commandInput.focus();
        });
        
        window.toggleRainDebug = function() { /* ... (unchanged) ... */ };
        window.toggleInsideDebug = function() { /* ... (unchanged) ... */ };
        // window.addEventListener('resize', resizeHealthHelixCanvas); // Removed

        drawGrid();
        if (commandInput) { commandInput.focus(); }
        updateWeatherEffects();
        addLogMessage("Tome unfurls its pages: Welcome, Wizard. The Ethereal Waves await your command.", 'system');

    </script>
</body>
</html>