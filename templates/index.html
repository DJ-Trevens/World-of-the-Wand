<!DOCTYPE html>
<html lang = "en">
<head>
    <meta charset = "UTF-8">
    <meta name = "viewport" content = "width = device-width, initial-scale = 1.0, user-scalable=no">
    <title>World of the Wand - Tome of Echoes</title>
    <link rel = "stylesheet" href = "{{url_for('game.static', filename = 'style.css')}}">

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script src="{{url_for('game.static', filename='game_texts.js')}}"></script> 
    <script>
        const socket = io({path: "/world-of-the-wand/socket.io"});
    </script>
</head>
<body> 
    <div class="main-ui-container">
        <div class="left-panel">
            <div id="commandLog"></div>
        </div>

        <div class="right-panel">
            <div id="mainHeaderStatusContainer">
                <div id="debugMenu">
                    <label>
                        <input type="checkbox" id="debugInfoToggle"> Debug Info
                    </label>
                    <div id="rainIntensityControl">
                        <label>
                            Rain Intensity: <input type="range" id="rainIntensitySlider" min="0" max="1" step="0.05">
                        </label>
                    </div>
                    <!-- New Debug Checkbox -->
                    <div id="simulateTickControl" style="display: none;">
                         <label>
                            <input type="checkbox" id="simulateTickToggle"> Simulate Server Tick
                        </label>
                    </div>
                    <button id="themeToggle" title="Switch to Light Mode">‚òÄÔ∏è</button>
                </div>
                <div id="mainHeaderStatus">World of the Wand</div>
            </div>

            <div id="gameCanvasContainer">
                <canvas id="gameCanvas">Your browser does not support the canvas element.</canvas>
                <div id="rainOverlay"></div>
            </div>
            
            <div id="commandInputBox">
                <form id="commandForm">
                    <label for="commandText">
                        <span id="tickIndicator">‚óè</span>Inscribe Thy Will:
                    </label>
                    <div id="commandText" contenteditable="true" spellcheck="false" autocomplete="off" role="textbox" aria-multiline="false"></div>
                    <button type="submit">Enact</button>
                </form>
            </div>
        </div>
    </div>

    <script>
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d');
        const gameCanvasContainer = document.getElementById('gameCanvasContainer');
        const rainOverlay = document.getElementById('rainOverlay');
        const mainHeaderStatus = document.getElementById('mainHeaderStatus');
        const commandLog = document.getElementById('commandLog');
        const commandForm = document.getElementById('commandForm');
        const commandInput = document.getElementById('commandText');
        const tickIndicator = document.getElementById('tickIndicator');
        const debugInfoToggle = document.getElementById('debugInfoToggle');
        const rainIntensitySlider = document.getElementById('rainIntensitySlider');
        const rainIntensityControl = document.getElementById('rainIntensityControl');
        const themeToggleButton = document.getElementById('themeToggle');
        const simulateTickToggle = document.getElementById('simulateTickToggle'); // New
        const simulateTickControl = document.getElementById('simulateTickControl'); // New

        const MOON_EMOJI = 'üåô'; 
        const SUN_EMOJI = '‚òÄÔ∏è'; 

        let showDebugInfo = false; 
        let selfPlayer = null;
        let otherPlayers = {}; 
        let visibleNPCs = [];
        let visibleTerrain = { walls: [], water: [] }; 
        let myPlayerID = null; 
        let GRID_WIDTH = 20; 
        let GRID_HEIGHT = 15;
        let GAME_TICK_RATE = 0.75;
        let prevSelfPlayerState = null;
        let currentSceneData = { InsideID: 0, name: "The Whispering Plains" }; 
        let globalWeather = { isRaining: true, intensity: 0.25 }; 
        let rainInterval = null;
        const RAIN_INTERVAL_DELAY = 50; 
        let isDragging = false;
        let startDragX, startDragY;
        let currentPanX = 0, currentPanY = 0; 
        let targetPanX = 0, targetPanY = 0;   
        const DEFAULT_FONT_SIZE_PX = 18;
        const X_STRETCH_FACTOR = 1.15; 
        const DEFAULT_CHAR_WIDTH_FALLBACK = (DEFAULT_FONT_SIZE_PX * 0.6) * X_STRETCH_FACTOR;
        const DEFAULT_CHAR_HEIGHT_FALLBACK = DEFAULT_FONT_SIZE_PX * 0.9; 
        
        let charRenderWidth = DEFAULT_CHAR_WIDTH_FALLBACK; 
        let charRenderHeight = DEFAULT_CHAR_HEIGHT_FALLBACK; 
        let charSizeEstimatedAtLeastOnce = false;
        let initialCenteringDone = false;
        let initialUIDone = false; 

        const FOG_CHAR = '‚ñí';    
        const FLOOR_CHAR = '¬∑';  
        const WALL_CHAR = '‚ñì';   
        const WATER_CHAR = '~'; 
        const PIXIE_CHAR_CLIENT = '*';
        const AURA_VISION_RANGE = 1;

        let currentGameZoomFactor = 1.4; 
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 3.0;
        const ZOOM_INCREMENT = 0.1;

        let simulateServerTickEnabled = false; // New
        let simulatedTickInterval = null;     // New

        function updateGameZoomCSS() {
            document.documentElement.style.setProperty('--game-zoom', currentGameZoomFactor);
            if (selfPlayer && charSizeEstimatedAtLeastOnce && !isDragging) {
                centerViewOnPlayer("zoom_change_recenter");
            }
        }
        updateGameZoomCSS(); 


        function applyTheme(theme) {
            if (theme === 'light') {
                document.body.classList.add('light-theme');
                document.body.classList.remove('dark-theme');
                themeToggleButton.textContent = MOON_EMOJI;
                themeToggleButton.title = "Switch to Dark Mode";
            } else { 
                document.body.classList.add('dark-theme'); 
                document.body.classList.remove('light-theme');
                themeToggleButton.textContent = SUN_EMOJI;
                themeToggleButton.title = "Switch to Light Mode";
            }
            localStorage.setItem('worldOfTheWandTheme', theme);
            if(selfPlayer && charSizeEstimatedAtLeastOnce) drawGrid();
        }

        function toggleTheme() {
            const currentThemeIsDark = document.body.classList.contains('dark-theme');
            applyTheme(currentThemeIsDark ? 'light' : 'dark');
        }
        themeToggleButton.addEventListener('click', toggleTheme);

        function initializeTheme() {
            const savedTheme = localStorage.getItem('worldOfTheWandTheme');
            if (savedTheme) { applyTheme(savedTheme); } 
            else { applyTheme(window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark'); }
        }
        
        function get_dx_dy_from_direction_str(s) { 
            const mapping = {'^': [0, -1], 'v': [0, 1], '<': [-1, 0], '>': [1, 0]};
            return mapping[s] || [0, 0];
        }
        function get_direction_str_from_dx_dy(dx, dy) { 
            const mapping = {"0,-1": '^', "0,1": 'v', "-1,0": '<', "1,0": '>'};
            return mapping[`${dx},${dy}`];
        }
        function getRelativeCoords(playerX, playerY, playerFacingChar, targetX, targetY) { 
            const worldDX = targetX - playerX; const worldDY = targetY - playerY;
            let pf;
            if (playerFacingChar === '^') pf = 'n'; else if (playerFacingChar === 'v') pf = 's';
            else if (playerFacingChar === '<') pf = 'w'; else if (playerFacingChar === '>') pf = 'e';
            else return { rx: worldDX, ry: worldDY };
            if (pf === 'n') return {rx: worldDX, ry: worldDY}; if (pf === 's') return {rx: -worldDX, ry: -worldDY};
            if (pf === 'w') return {rx: -worldDY, ry: worldDX}; if (pf === 'e') return {rx: worldDY, ry: -worldDX};
            return { rx: worldDX, ry: worldDY };
        }
        function manhattanDistance(x1, y1, x2, y2) { return Math.abs(x1 - x2) + Math.abs(y1 - y2); }
        
        function isVisible(observerX, observerY, observerChar, targetX, targetY, scry = false) { 
            if (!observerChar || !selfPlayer) return false; 
            let manhattanDist = manhattanDistance(observerX, observerY, targetX, targetY);
            if (scry || manhattanDist <= AURA_VISION_RANGE) return true;
            
            const {rx, ry} = getRelativeCoords(observerX, observerY, observerChar, targetX, targetY);
            const clientObservableDepth = 10; 
            const OBSERVABLE_WIDTH_CONST = 1.0; 
            
            if (ry < 0 && -ry <= clientObservableDepth && Math.abs(rx) <= Math.floor(-ry * OBSERVABLE_WIDTH_CONST )) return true;
            
            return false;
        }

        function addLogMessage(message, type = 'lore') { 
            const logEntry = document.createElement('div');
            let displayStyle = 'ink';
            switch (type) {
                case 'event-bad': case 'chat-shout': case 'server-major-event': 
                case 'player-trade': case 'player-damage': case 'welcome-message': 
                case 'sensory-magic': 
                    displayStyle = 'mana'; break;
                case 'sensory-sound': case 'sensory-smell': case 'sensory-sight':
                case 'system': case 'event-good': case 'spell-cast': 
                case 'lore': case 'user-input': case 'chat-say':          
                default: displayStyle = 'ink'; break;
            }
            logEntry.classList.add('log-entry', `log-style-${displayStyle}`, `log-type-${type}`);
            logEntry.textContent = message; 
            commandLog.appendChild(logEntry);
            requestAnimationFrame(() => { commandLog.scrollTop = commandLog.scrollHeight; });
        }
        function logRandomizedEvent(mainKey, subKey, placeholders = {}, messageType = 'lore') { 
            const message = getRandomGameText(mainKey, subKey, placeholders);
            addLogMessage(message, messageType);
        }
        function updateStatus(statusText) { 
            if (statusText) {
                mainHeaderStatus.textContent = statusText;
            } else if (selfPlayer) {
                let healthPercentage = selfPlayer.max_health > 0 ? Math.round((selfPlayer.current_health / selfPlayer.max_health) * 100) : 0;
                let baseStatus = `${healthPercentage}% Health | ${selfPlayer.current_mana} Mana`;
                if (showDebugInfo) { 
                     baseStatus += `/${selfPlayer.max_mana}`;
                }
                baseStatus += ` | ${selfPlayer.gold || 0} Gold | ${selfPlayer.potions} Potions | ${selfPlayer.walls} Walls`;
                
                if (showDebugInfo) {
                    let locationType = currentSceneData.InsideID === 0 ? 'Outdoors' : `Indoors (ID:${currentSceneData.InsideID})`; 
                     baseStatus = `Scene: (${selfPlayer.scene_x},${selfPlayer.scene_y}) ${currentSceneData.name} [${locationType}] | ${selfPlayer.char}:(${selfPlayer.x},${selfPlayer.y}) ${selfPlayer.is_wet ? '(Wet)' : ''} | ${baseStatus}`;
                }
                mainHeaderStatus.textContent = baseStatus;
            } else {
                mainHeaderStatus.textContent = "Connecting to the World of the Wand...";
            }
        }
        
        function estimateCharacterSize(context = "unknown") { 
            console.log(`[estimateCharacterSize context: ${context}] Start. charSizeEstimatedAtLeastOnce: ${charSizeEstimatedAtLeastOnce}`);
            const testChar = 'M'; 
            const computedStyle = getComputedStyle(document.documentElement);
            const fontFamily = computedStyle.getPropertyValue('--font-game').trim() || "'Courier New', monospace";
            const fontSize = DEFAULT_FONT_SIZE_PX + "px";
            const tempSpan = document.createElement('span');
            tempSpan.style.fontFamily = fontFamily;
            tempSpan.style.fontSize = fontSize;
            tempSpan.style.lineHeight = computedStyle.getPropertyValue('line-height') || String(DEFAULT_FONT_SIZE_PX * 0.9);
            tempSpan.style.whiteSpace = 'pre';
            tempSpan.style.visibility = 'hidden';
            tempSpan.style.position = 'absolute';
            tempSpan.textContent = testChar;
            document.body.appendChild(tempSpan);
            let measuredWidth = tempSpan.offsetWidth;
            let measuredHeight = tempSpan.offsetHeight;
            document.body.removeChild(tempSpan);

            if (measuredWidth > 0 && measuredHeight > 0) {
                charRenderWidth = measuredWidth * X_STRETCH_FACTOR; 
                charRenderHeight = measuredHeight;
            } else {
                charRenderWidth = DEFAULT_CHAR_WIDTH_FALLBACK; 
                charRenderHeight = DEFAULT_CHAR_HEIGHT_FALLBACK;
                console.warn(`[estimateCharacterSize context: ${context}] tempSpan method yielded non-positive dimensions. Reverting to PREDEFINED FALLBACK.`);
            }
            console.log(`[estimateCharacterSize context: ${context}] Char size (W x H): ${charRenderWidth.toFixed(2)} x ${charRenderHeight.toFixed(2)} based on '${testChar}' (X-stretch applied)`);
            
            if (GRID_WIDTH > 0 && GRID_HEIGHT > 0 && charRenderWidth > 0 && charRenderHeight > 0) {
                gameCanvas.width = GRID_WIDTH * charRenderWidth;
                gameCanvas.height = GRID_HEIGHT * charRenderHeight;
                console.log(`[estimateCharacterSize context: ${context}] Canvas element ATTR resized to: ${gameCanvas.width}x${gameCanvas.height}px`);
            } else {
                console.warn(`[estimateCharacterSize context: ${context}] Could not resize canvas, invalid grid/char dimensions.`);
            }
            charSizeEstimatedAtLeastOnce = true; 
        }

        function drawGrid() {
            if (!ctx) return; 

            if (!charSizeEstimatedAtLeastOnce || GRID_WIDTH === 0 || GRID_HEIGHT === 0 || gameCanvas.width === 0 || gameCanvas.height === 0) {
                const canvasWidth = gameCanvas.width || (DEFAULT_CHAR_WIDTH_FALLBACK * GRID_WIDTH) || 300; 
                const canvasHeight = gameCanvas.height || (DEFAULT_CHAR_HEIGHT_FALLBACK * GRID_HEIGHT) || 200; 
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                const tempFont = "16px 'Courier New', monospace";
                const tempFill = getComputedStyle(document.body).getPropertyValue('--text-primary') || "#E2E8F0"; 
                ctx.font = tempFont; ctx.fillStyle = tempFill;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                const loadingBg = getComputedStyle(document.body).getPropertyValue('--bg-secondary') || '#2d3748';
                ctx.fillStyle = loadingBg;
                ctx.fillRect(0,0, canvasWidth, canvasHeight);
                ctx.fillStyle = tempFill; 
                ctx.fillText("The mists obscure your vision...", canvasWidth / 2, canvasHeight / 2 - 10);
                ctx.fillText("(Awaiting server data or font readiness)", canvasWidth / 2, canvasHeight / 2 + 10);
                if (!charSizeEstimatedAtLeastOnce) { 
                    console.warn("[drawGrid] charSize not estimated, attempting now.");
                    estimateCharacterSize("drawGrid_fallback_estimate");
                }
                return;
            }
            
            const bodyStyle = getComputedStyle(document.body); 
            ctx.fillStyle = bodyStyle.getPropertyValue('--canvas-bg-consistent').trim();
            ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

            if (!selfPlayer) { 
                const tempFont = "16px 'Courier New', monospace";
                const tempFill = bodyStyle.getPropertyValue('--text-game-floor-consistent').trim() || "#9CA3AF"; 
                ctx.font = tempFont; ctx.fillStyle = tempFill;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText("(Awaiting player manifestation...)", gameCanvas.width / 2, gameCanvas.height / 2);
                return;
            }

            const gameFontFamily = bodyStyle.getPropertyValue('--font-game').trim() || "'Courier New', monospace";
            ctx.font = `${DEFAULT_FONT_SIZE_PX}px ${gameFontFamily}`;
            ctx.textBaseline = 'top'; 
            ctx.textAlign = 'left';   

            const floorColor = bodyStyle.getPropertyValue('--text-game-floor-consistent').trim();
            const wallColor = bodyStyle.getPropertyValue('--text-game-wall-consistent').trim();
            const waterColor = bodyStyle.getPropertyValue('--text-game-water-consistent').trim();
            const fogColor = bodyStyle.getPropertyValue('--text-game-fog-consistent').trim();
            const selfPlayerBaseColor = bodyStyle.getPropertyValue('--text-game-self-consistent').trim();
            const otherPlayerBaseColor = bodyStyle.getPropertyValue('--text-game-other-consistent').trim();
            const npcPixieColor = bodyStyle.getPropertyValue('--text-game-npc-pixie-consistent').trim() || otherPlayerBaseColor;
            const wetPlayerTintColor = bodyStyle.getPropertyValue('--text-game-wet-tint-consistent').trim();

            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    let charToDraw = FLOOR_CHAR;
                    let colorToUse = floorColor;
                    
                    if (visibleTerrain.water && visibleTerrain.water.some(wt => wt.x === x && wt.y === y)) {
                        charToDraw = WATER_CHAR; colorToUse = waterColor;
                    } else if (visibleTerrain.walls && visibleTerrain.walls.some(w => w.x === x && w.y === y)) {
                        charToDraw = WALL_CHAR; colorToUse = wallColor;
                    }
                    
                    if (!isVisible(selfPlayer.x, selfPlayer.y, selfPlayer.char, x, y)) {
                        charToDraw = FOG_CHAR; colorToUse = fogColor;
                    }
                    
                    ctx.fillStyle = colorToUse;
                    ctx.fillText(charToDraw, x * charRenderWidth, y * charRenderHeight);
                }
            }
            
            if (visibleNPCs) {
                visibleNPCs.forEach(npc => {
                    if (isVisible(selfPlayer.x, selfPlayer.y, selfPlayer.char, npc.x, npc.y)) {
                        ctx.fillStyle = npcPixieColor; 
                        ctx.fillText(npc.char || PIXIE_CHAR_CLIENT, npc.x * charRenderWidth, npc.y * charRenderHeight);
                    }
                });
            }

            for (const id in otherPlayers) {
                const p = otherPlayers[id];
                if (isVisible(selfPlayer.x, selfPlayer.y, selfPlayer.char, p.x, p.y)) {
                    ctx.fillStyle = otherPlayerBaseColor;
                    ctx.fillText(p.char, p.x * charRenderWidth, p.y * charRenderHeight);
                    if (p.is_wet) {
                        ctx.fillStyle = wetPlayerTintColor; 
                        ctx.fillRect(p.x * charRenderWidth, p.y * charRenderHeight, charRenderWidth, charRenderHeight);
                        ctx.fillStyle = otherPlayerBaseColor; 
                        ctx.fillText(p.char, p.x * charRenderWidth, p.y * charRenderHeight);
                    }
                }
            }
            
             if (isVisible(selfPlayer.x, selfPlayer.y, selfPlayer.char, selfPlayer.x, selfPlayer.y, true )) { 
                ctx.fillStyle = selfPlayerBaseColor;
                ctx.fillText(selfPlayer.char, selfPlayer.x * charRenderWidth, selfPlayer.y * charRenderHeight);
                if (selfPlayer.is_wet) {
                    ctx.fillStyle = wetPlayerTintColor; 
                    ctx.fillRect(selfPlayer.x * charRenderWidth, selfPlayer.y * charRenderHeight, charRenderWidth, charRenderHeight);
                    ctx.fillStyle = selfPlayerBaseColor; 
                    ctx.fillText(selfPlayer.char, selfPlayer.x * charRenderWidth, selfPlayer.y * charRenderHeight);
                }
            }
        }

        function startRainEffect(intensity) { 
            if (rainInterval) clearInterval(rainInterval);
            rainOverlay.innerHTML = ''; 
            rainInterval = setInterval(() => {
                if (Math.random() < (intensity * 0.5) ) { 
                    const drop = document.createElement('div');
                    drop.classList.add('raindrop');
                    drop.style.left = Math.random() * 100 + '%';
                    const duration = 0.4 + Math.random() * 0.4; 
                    drop.style.animationDuration = duration + 's';
                    drop.style.animationDelay = Math.random() * 0.2 + 's'; 
                    rainOverlay.appendChild(drop);
                    drop.addEventListener('animationend', () => drop.remove());
                }
            }, RAIN_INTERVAL_DELAY);
        }
        function stopRainEffect() { 
            if (rainInterval) clearInterval(rainInterval);
            rainInterval = null;
            rainOverlay.innerHTML = ''; 
        }
        function updateWeatherEffects() { 
            if (globalWeather.isRaining && currentSceneData.InsideID === 0) {
                if (!rainInterval || rainIntensitySlider.valueAsNumber !== globalWeather.intensity) {
                    globalWeather.intensity = rainIntensitySlider.valueAsNumber; 
                    startRainEffect(globalWeather.intensity);
                }
            } else {
                if (rainInterval) stopRainEffect();
            }
        }
        gameCanvasContainer.addEventListener('mousedown', (e) => { 
            if (e.button !== 0) return; 
            isDragging = true; document.body.classList.add('is-dragging');
            gameCanvasContainer.style.cursor = 'grabbing';
            const currentStyle = getComputedStyle(gameCanvas);
            const currentPanXFromCSS = parseFloat(currentStyle.getPropertyValue('--pan-x')) || currentPanX;
            const currentPanYFromCSS = parseFloat(currentStyle.getPropertyValue('--pan-y')) || currentPanY;
            startDragX = e.clientX - currentPanXFromCSS; 
            startDragY = e.clientY - currentPanYFromCSS;
            gameCanvas.style.transition = 'none'; 
        });
        window.addEventListener('mousemove', (e) => { 
            if (!isDragging) return;
            currentPanX = e.clientX - startDragX; currentPanY = e.clientY - startDragY;
            gameCanvas.style.setProperty('--pan-x', `${currentPanX}px`);
            gameCanvas.style.setProperty('--pan-y', `${currentPanY}px`);
        });
        window.addEventListener('mouseup', (e) => { 
            if (e.button !== 0 || !isDragging) return;
            isDragging = false; document.body.classList.remove('is-dragging');
            gameCanvasContainer.style.cursor = 'grab';
            if (!isDragging) { gameCanvas.style.transition = 'transform 0.3s ease-out'; }
        });
        gameCanvasContainer.addEventListener('mouseleave', () => { 
            if(isDragging){ 
                isDragging = false; document.body.classList.remove('is-dragging');
                gameCanvasContainer.style.cursor = 'grab';
                gameCanvas.style.transition = 'transform 0.3s ease-out';
            }
        });
        
        function centerViewOnPlayer(context = "unknown") { 
            const containerHeight = gameCanvasContainer.clientHeight;
            const containerWidth = gameCanvasContainer.clientWidth;
            
            if (!selfPlayer || !charSizeEstimatedAtLeastOnce || GRID_WIDTH === 0 || GRID_HEIGHT === 0 || 
                containerHeight <= 0 || containerWidth <=0 || 
                charRenderWidth <=0 || charRenderHeight <=0 || 
                gameCanvas.width === 0 || gameCanvas.height === 0) { 
                 console.warn(`[centerViewOnPlayer context: ${context}] PRECONDITIONS NOT MET. Canvas(W:${gameCanvas.width},H:${gameCanvas.height}), Char(W:${charRenderWidth.toFixed(2)}, H:${charRenderHeight.toFixed(2)})`);
                 gameCanvas.style.setProperty('--pan-x', `0px`); gameCanvas.style.setProperty('--pan-y', `0px`);
                return; 
            }
            const playerVisualCenterX_unscaled = (selfPlayer.x * charRenderWidth) + (charRenderWidth / 2);
            const playerVisualCenterY_unscaled = (selfPlayer.y * charRenderHeight) + (charRenderHeight / 2);
            targetPanX = (containerWidth / 2) - (playerVisualCenterX_unscaled * currentGameZoomFactor);
            targetPanY = (containerHeight / 2) - (playerVisualCenterY_unscaled * currentGameZoomFactor);
            currentPanX = targetPanX; currentPanY = targetPanY;
            gameCanvas.style.transition = 'transform 0.3s ease-out'; 
            gameCanvas.style.setProperty('--pan-x', `${currentPanX}px`);
            gameCanvas.style.setProperty('--pan-y', `${currentPanY}px`);
        }

        gameCanvasContainer.addEventListener('wheel', function(event) {
            event.preventDefault();
            const delta = Math.sign(event.deltaY);
            let newZoom = currentGameZoomFactor;
            if (delta < 0) { 
                newZoom = Math.min(MAX_ZOOM, currentGameZoomFactor + ZOOM_INCREMENT);
            } else { 
                newZoom = Math.max(MIN_ZOOM, currentGameZoomFactor - ZOOM_INCREMENT);
            }
            if (newZoom !== currentGameZoomFactor) {
                currentGameZoomFactor = newZoom;
                updateGameZoomCSS();
            }
        }, { passive: false });

        let initialPinchDistance = null;
        let lastZoomFactorOnPinchStart = currentGameZoomFactor;

        gameCanvasContainer.addEventListener('touchstart', function(event) {
            if (event.touches.length === 2) {
                event.preventDefault(); 
                initialPinchDistance = Math.hypot(
                    event.touches[0].clientX - event.touches[1].clientX,
                    event.touches[0].clientY - event.touches[1].clientY
                );
                lastZoomFactorOnPinchStart = currentGameZoomFactor; 
            }
        }, { passive: false });

        gameCanvasContainer.addEventListener('touchmove', function(event) {
            if (event.touches.length === 2 && initialPinchDistance !== null) {
                event.preventDefault();
                const currentPinchDistance = Math.hypot(
                    event.touches[0].clientX - event.touches[1].clientX,
                    event.touches[0].clientY - event.touches[1].clientY
                );
                if (initialPinchDistance > 0) { 
                    const zoomRatio = currentPinchDistance / initialPinchDistance;
                    let newZoom = lastZoomFactorOnPinchStart * zoomRatio;
                    newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));
                    
                    if (newZoom !== currentGameZoomFactor) {
                         currentGameZoomFactor = newZoom;
                         updateGameZoomCSS();
                    }
                }
            }
        }, { passive: false });

        gameCanvasContainer.addEventListener('touchend', function(event) {
            if (event.touches.length < 2) {
                initialPinchDistance = null; 
            }
        });


        debugInfoToggle.addEventListener('change', (event) => { 
            showDebugInfo = event.target.checked;
            localStorage.setItem('showDebugInfo', JSON.stringify(showDebugInfo)); 
            rainIntensityControl.style.display = showDebugInfo ? 'block' : 'none';
            simulateTickControl.style.display = showDebugInfo ? 'block' : 'none'; // Show/hide simulate tick
            if (!showDebugInfo) { // If debug info is turned off, also turn off simulation
                simulateTickToggle.checked = false;
                simulateServerTickEnabled = false;
                if (simulatedTickInterval) clearInterval(simulatedTickInterval);
                simulatedTickInterval = null;
            }
            updateStatus(); 
        });
        rainIntensitySlider.addEventListener('input', (event) => { 
            const newIntensity = parseFloat(event.target.value);
            if (globalWeather.intensity !== newIntensity) {
                globalWeather.intensity = newIntensity;
                localStorage.setItem('rainIntensity', globalWeather.intensity.toString());
                if (globalWeather.isRaining && currentSceneData.InsideID === 0) startRainEffect(globalWeather.intensity); 
            }
        });

        simulateTickToggle.addEventListener('change', (event) => {
            simulateServerTickEnabled = event.target.checked;
            if (simulateServerTickEnabled) {
                if (simulatedTickInterval) clearInterval(simulatedTickInterval); // Clear any old one
                simulatedTickInterval = setInterval(() => {
                    if (tickIndicator) {
                        tickIndicator.classList.add('tick-flash');
                        if(tickFlashTimeout) clearTimeout(tickFlashTimeout);
                        tickFlashTimeout = setTimeout(() => { if(tickIndicator) tickIndicator.classList.remove('tick-flash'); }, 150);
                    }
                    if (selfPlayer) { // Only draw if player data exists
                        drawGrid();
                        // updateStatus(); // updateStatus is called by game_update, less critical for purely visual tick
                    }
                }, GAME_TICK_RATE * 1000);
            } else {
                if (simulatedTickInterval) clearInterval(simulatedTickInterval);
                simulatedTickInterval = null;
            }
        });


        const resizeObserver = new ResizeObserver(entries => { 
            for (let entry of entries) {
                if (entry.target === gameCanvasContainer) {
                    const newHeight = entry.contentRect.height; const newWidth = entry.contentRect.width;
                    console.log(`[ResizeObserver] gameCanvasContainer new dimensions: W=${newWidth}, H=${newHeight}`);
                    if (newHeight > 0 && newWidth > 0 && selfPlayer && !initialCenteringDone) {
                        console.log(`[ResizeObserver] Container has valid dimensions. Attempting initial setup & centering.`);
                        if (!charSizeEstimatedAtLeastOnce || charRenderWidth <=0 || charRenderHeight <=0 ) {
                           estimateCharacterSize("ResizeObserver_triggered_estimate");
                        }
                        centerViewOnPlayer("ResizeObserver_initial_center");
                        initialCenteringDone = true; 
                        if (!initialUIDone) {
                            updateStatus(); updateWeatherEffects(); 
                            if(showDebugInfo) logRandomizedEvent('LORE', 'WELCOME', { playerId: myPlayerID }, 'welcome-message');
                            if (currentSceneData.InsideID === 0 && globalWeather.isRaining) logRandomizedEvent('LORE', 'INITIAL_RAIN', {}, 'system');
                            initialUIDone = true;
                        }
                    } else if (newHeight > 0 && newWidth > 0 && selfPlayer && initialCenteringDone && !isDragging) {
                        console.log("[ResizeObserver] Window/container resized. Re-centering player.");
                        centerViewOnPlayer("ResizeObserver_recenter");
                    }
                }
            }
        });
        if (gameCanvasContainer) resizeObserver.observe(gameCanvasContainer);

        socket.on('connect', () => { 
            console.log("Socket.IO connected successfully! SID (client-side):", socket.id);
            logRandomizedEvent('LORE', 'CONNECTION_ESTABLISHED', {}, 'system');
        });
        socket.on('connect_error', (err) => { 
            console.error("Socket.IO connection error:", err);
            addLogMessage(`Tome screams: Connection Error! ${err.message} (Type: ${err.type}, Description: ${err.description})`, 'event-bad');
            updateStatus("Connection failed. Trying to reconnect...");
        });
        socket.on('initial_game_data', (data) => { 
            console.log("Received 'initial_game_data':", data);
            if (!data || !data.player_data || typeof data.grid_width !== 'number' || typeof data.grid_height !== 'number') {
                logRandomizedEvent('LORE', 'CORRUPT_MANIFESTATION_SERVER', {}, 'event-bad');
                if (!charSizeEstimatedAtLeastOnce) estimateCharacterSize("initial_data_fail_estimate");
                drawGrid(); return;
            }
            selfPlayer = data.player_data; myPlayerID = selfPlayer.id; 
            GRID_WIDTH = data.grid_width; GRID_HEIGHT = data.grid_height; GAME_TICK_RATE = data.tick_rate;
            otherPlayers = {}; 
            visibleTerrain = { walls: [], water: [] }; 
            visibleNPCs = data.visible_npcs || []; 
            globalWeather.intensity = data.default_rain_intensity || 0.25; 
            rainIntensitySlider.value = globalWeather.intensity;

            if (data.other_players_in_scene) data.other_players_in_scene.forEach(p => { if (p.id !== myPlayerID) otherPlayers[p.id] = p; });
            prevSelfPlayerState = { ...selfPlayer };
            const savedDebugInfo = localStorage.getItem('showDebugInfo'); 
            showDebugInfo = savedDebugInfo !== null ? JSON.parse(savedDebugInfo) : false; 
            debugInfoToggle.checked = showDebugInfo; 
            rainIntensityControl.style.display = showDebugInfo ? 'block' : 'none';
            simulateTickControl.style.display = showDebugInfo ? 'block' : 'none'; // Show/hide on load based on debug info
            
            if (!charSizeEstimatedAtLeastOnce) { 
                estimateCharacterSize("initial_data_pre_font_ready");
            }

            document.fonts.ready.then(() => {
                console.log("Fonts ready. Initial data processed.");
                estimateCharacterSize("initial_data_fonts_ready"); 
                if (selfPlayer) {
                    drawGrid(); updateStatus(); 
                    if (gameCanvasContainer.clientHeight > 0 && !initialCenteringDone) {
                        centerViewOnPlayer("initial_data_direct_center_attempt");
                        initialCenteringDone = true;
                        if(!initialUIDone){
                             updateWeatherEffects(); 
                             if(showDebugInfo) {
                                logRandomizedEvent('LORE', 'WELCOME', { playerId: myPlayerID }, 'welcome-message');
                             }
                             if (currentSceneData.InsideID === 0 && globalWeather.isRaining) logRandomizedEvent('LORE', 'INITIAL_RAIN', {}, 'system');
                             initialUIDone = true;
                        }
                    } else if (gameCanvasContainer.clientHeight <= 0 && !initialCenteringDone) {
                        console.warn("Container height 0. ResizeObserver should handle. Setting fallback timeout.");
                        setTimeout(() => {
                            if (!initialCenteringDone && gameCanvasContainer.clientHeight > 0) {
                                if (!charSizeEstimatedAtLeastOnce) estimateCharacterSize("initial_data_timeout_fallback_estimate");
                                centerViewOnPlayer("initial_data_timeout_fallback_center");
                                initialCenteringDone = true;
                                if (!initialUIDone) { updateWeatherEffects(); if(showDebugInfo){logRandomizedEvent('LORE', 'WELCOME', { playerId: myPlayerID }, 'welcome-message');} if (currentSceneData.InsideID === 0 && globalWeather.isRaining) logRandomizedEvent('LORE', 'INITIAL_RAIN', {}, 'system'); initialUIDone = true; }
                            } else if (!initialCenteringDone) { console.error("Container height still 0 after fallback timeout. Centering failed."); logRandomizedEvent('LORE', 'CENTERING_ERROR', {}, 'event-bad'); }
                        }, 300); 
                    } else if (initialCenteringDone && !initialUIDone) { updateWeatherEffects(); if(showDebugInfo){logRandomizedEvent('LORE', 'WELCOME', { playerId: myPlayerID }, 'welcome-message');} if (currentSceneData.InsideID === 0 && globalWeather.isRaining) logRandomizedEvent('LORE', 'INITIAL_RAIN', {}, 'system'); initialUIDone = true; }
                } else { logRandomizedEvent('LORE', 'MANIFESTATION_FAILED_NO_PLAYER_DATA', {}, 'event-bad'); }
            }).catch(err => { 
                console.error("Font loading error:", err);
                logRandomizedEvent('LORE', 'FONT_SORCERY_FAILED', {}, 'event-bad');
                 if (selfPlayer) { 
                    charSizeEstimatedAtLeastOnce = false; estimateCharacterSize("fonts_catch_fallback"); 
                    drawGrid(); updateStatus(); 
                     setTimeout(() => {
                        if (!initialCenteringDone && gameCanvasContainer.clientHeight > 0) {
                           centerViewOnPlayer("fonts_catch_centering");
                           initialCenteringDone = true;
                        } else if(!initialCenteringDone) { console.error("Container height still 0 after font catch. Centering failed."); }
                        if (!initialUIDone) { updateWeatherEffects(); initialUIDone = true; }
                     }, 250);
                    addLogMessage("Attempting to render world despite font issues...", 'system');
                 } else { logRandomizedEvent('LORE', 'FONT_AND_DATA_ERROR', {}, 'event-bad'); }
             });
        });
        socket.on('player_entered_your_scene', (newPlayerData) => { 
            if (myPlayerID && newPlayerData.id !== myPlayerID && selfPlayer) { 
                otherPlayers[newPlayerData.id] = newPlayerData; drawGrid();
                logRandomizedEvent('LORE', 'PLAYER_ARRIVES', { playerName: newPlayerData.name || 'A new sorcerer' }, 'event-good');
            }
        });
        socket.on('player_exited_your_scene', (exitedPlayerData) => { 
            if (otherPlayers[exitedPlayerData.id]) {
                const leftPlayerName = exitedPlayerData.name || otherPlayers[exitedPlayerData.id].name || 'A sorcerer';
                delete otherPlayers[exitedPlayerData.id]; drawGrid();
                logRandomizedEvent('LORE', 'PLAYER_DEPARTS', { playerName: leftPlayerName }, 'lore');
            }
        });
        socket.on('lore_message', (data) => { 
            let mainKeyToUse = 'GENERIC';
            let subKeyToUse = (data.type || 'lore').toUpperCase(); 
            let placeholdersToUse = { message: data.message || "An unknown lore event occurred." }; 
            if (data.messageKey) {
                const keys = data.messageKey.split('.');
                if (GAME_TEXTS[keys[0]]) { 
                    mainKeyToUse = keys[0];
                    if (keys.length > 1) {
                        const potentialSubKey = keys.slice(1).join('.');
                        if (GAME_TEXTS[mainKeyToUse] && GAME_TEXTS[mainKeyToUse][potentialSubKey]) {
                            subKeyToUse = potentialSubKey;
                        } else { 
                            subKeyToUse = mainKeyToUse.toUpperCase(); mainKeyToUse = 'GENERIC'; 
                            placeholdersToUse = { message: data.message || `Content for ${data.messageKey} missing.`};
                        }
                    } else { subKeyToUse = null; } 
                    if(data.placeholders) placeholdersToUse = {...placeholdersToUse, ...data.placeholders};
                } else { placeholdersToUse = { message: data.message || `Unknown event key: ${data.messageKey}` }; }
            }
            logRandomizedEvent(mainKeyToUse, subKeyToUse, placeholdersToUse, data.type || 'lore');
        });
        socket.on('chat_message', (data) => { 
            let prefix = ""; let messageType = 'chat-say'; 
            let textKey = data.type === 'shout' ? 'CHAT_SHOUT' : 'CHAT_SAY';
            prefix = getRandomGameText('LORE', textKey, { 
                senderName: data.sender_name || (data.type === 'shout' ? 'A distant voice' : 'Someone nearby'),
                sceneCoords: data.scene_coords || '(unknown location)'
            });
            addLogMessage(prefix + data.message, data.type === 'shout' ? 'chat-shout' : 'chat-say');
        });
        
        socket.on('player_event', (data) => { 
            if (data.type === 'stepped_in_water' && data.sid === myPlayerID) { 
                console.log("Client: Received stepped_in_water event. Playing sound (placeholder)... SPLASH!");
            }
        });
        
        let tickFlashTimeout = null;
        socket.on('game_update', (data) => { 
             if (!selfPlayer || !myPlayerID || !data.self_player_data) { return; }
             // Only flash if not simulating, to avoid double flashing
            if(tickIndicator && !simulateServerTickEnabled) {
                tickIndicator.classList.add('tick-flash'); 
                if(tickFlashTimeout) clearTimeout(tickFlashTimeout); 
                tickFlashTimeout = setTimeout(() => { if(tickIndicator) tickIndicator.classList.remove('tick-flash'); }, 150); 
            }
            
            const oldSceneX = selfPlayer.scene_x; const oldSceneY = selfPlayer.scene_y;
            const oldX = selfPlayer.x; const oldY = selfPlayer.y; const oldChar = selfPlayer.char;
            
            selfPlayer = data.self_player_data; 
            otherPlayers = {}; 
            if(data.visible_other_players) data.visible_other_players.forEach(p => { if (p.id !== myPlayerID) otherPlayers[p.id] = p; }); 
            visibleTerrain = data.visible_terrain || { walls: [], water: [] }; 
            visibleNPCs = data.visible_npcs || []; 

            updateStatus(); 
            
            const sceneChanged = selfPlayer.scene_x !== oldSceneX || selfPlayer.scene_y !== oldSceneY;
            const positionChanged = selfPlayer.x !== oldX || selfPlayer.y !== oldY;
            const facingChanged = selfPlayer.char !== oldChar;

            if (sceneChanged) { /* Server lore_message handles this */ }
            else if (positionChanged && (selfPlayer.x !== oldX || selfPlayer.y !== oldY)) { 
                logRandomizedEvent('PLAYER_MOVE', null, {x: selfPlayer.x, y: selfPlayer.y, direction: getDirectionWord(selfPlayer.char)}, 'lore');
            }
            else if (facingChanged) {
                logRandomizedEvent('PLAYER_TURN', null, {direction: getDirectionWord(selfPlayer.char), x: selfPlayer.x, y: selfPlayer.y}, 'lore');
            }
            
            if (sceneChanged || positionChanged || facingChanged) {
                 if (!isDragging) {
                    if(!charSizeEstimatedAtLeastOnce || charRenderWidth <= 0 || charRenderHeight <= 0 || gameCanvas.width === 0){
                        estimateCharacterSize("game_update_pre_recenter_estimate"); 
                    }
                    setTimeout(() => centerViewOnPlayer("game_update_recentering"), 0); 
                }
            }
            prevSelfPlayerState = { ...selfPlayer }; 
            drawGrid(); 
            
            if (!charSizeEstimatedAtLeastOnce && GRID_WIDTH > 0 && GRID_HEIGHT > 0) { 
                 estimateCharacterSize("game_update_reestimate"); 
                 if(!isDragging) setTimeout(() => centerViewOnPlayer("game_update_after_reestimate_centering"), 0);
            }
            updateWeatherEffects(); 
        });
        function getDirectionWord(char) { 
            if (char === '^') return "North"; if (char === 'v') return "South";
            if (char === '<') return "West";  if (char === '>') return "East";
            return "an unknown direction";
        }
        socket.on('action_feedback', (data) => { 
            console.log("Client received 'action_feedback':", data);
            const baseKey = 'ACTION_SENT_FEEDBACK';
            const subKey = data.messageKey && data.messageKey.startsWith(baseKey + '.') ? 
                           data.messageKey.substring(baseKey.length + 1) : 
                           (data.success ? 'ACTION_QUEUED' : 'ACTION_FAILED_UNKNOWN_COMMAND');

            const placeholders = data.placeholders || { actionWord: data.actionWordAttempted || "", message: data.message };
            const messageType = data.success ? 'system' : 'event-bad';
            
            let textToLog = getRandomGameText(baseKey, subKey, placeholders);

            if (textToLog.startsWith("Missing text for:") || textToLog.startsWith("No text variants for:") || textToLog.includes("{message}")) { 
                if (data.message && data.message.trim() !== "") {
                    textToLog = (data.success ? "Tome nods: " : "Tome objects: ") + data.message;
                } else {
                    textToLog = (data.success ? "Tome nods: Action acknowledged." : "Tome objects: Action failed.");
                }
            }
            addLogMessage(textToLog, messageType);
        });
        socket.on('disconnect', (reason) => { 
            console.log("Socket.IO disconnected. Reason:", reason);
            updateStatus(`Severed from the Ethereal Plane! (${reason})`);
            logRandomizedEvent('LORE', 'DISCONNECTED', { reason: reason }, 'event-bad');
            selfPlayer = null; otherPlayers = {}; visibleTerrain = {walls:[], water:[]}; visibleNPCs = []; prevSelfPlayerState = null;
            stopRainEffect(); drawGrid(); 
        });
        
        const ACTION_ALIASES = {
            "move": ["move", "go", "walk", "step", "head", "run"], "look": ["look", "face", "turn"],
            "cast": ["cast", "zap", "fire", "spell"], "drink": ["drink", "quaff", "use"],
            "say": ["say", "tell", "whisper", "'"], "shout": ["shout", "yell", "scream", "!"], 
            "help": ["help", "?"],
            "build": ["build", "construct", "erect", "b"], 
            "destroy": ["destroy", "dismantle", "remove", "d"]
        };
        const DIRECTION_ALIASES = {
            "north": {char: '^', dx: 0,  dy: -1, aliases: ["north", "n", "up"]},
            "south": {char: 'v', dx: 0,  dy: 1,  aliases: ["south", "s", "down"]},
            "west":  {char: '<', dx: -1, dy: 0,  aliases: ["west", "w", "left", "lft", "l"]},
            "east":  {char: '>', dx: 1,  dy: 0,  aliases: ["east", "e", "right", "rght", "rgt", "r"]},
            "forward":  {relative: true, aliases: ["forward", "forwards", "fwd", "f", "ahead", "straight", "onward", "onwards"]},
            "backward": {relative: true, aliases: ["backward", "backwards", "back", "bck", "behind", "b"]},
        };
        function parseAction(actionWord) {
            actionWord = actionWord.toLowerCase();
            for (const canonicalAction in ACTION_ALIASES) if (ACTION_ALIASES[canonicalAction].includes(actionWord)) return canonicalAction;
            return null;
        }
        function parseDirection(directionStr, curFacing) {
            directionStr = directionStr.toLowerCase(); let result = {char: curFacing, dx: 0, dy: 0, isValid: false}; 
            for (const dirKey in DIRECTION_ALIASES) { const config = DIRECTION_ALIASES[dirKey];
                if (config.aliases.includes(directionStr)) {
                    if (config.relative) {
                        result.isValid = true; const [currentDx, currentDy] = get_dx_dy_from_direction_str(curFacing);
                        if (currentDx === 0 && currentDy === 0 && !['^','v','<','>'].includes(curFacing)) { result.isValid = false; break; }
                        if (dirKey === "forward") { result.char = curFacing; result.dx = currentDx; result.dy = currentDy; }
                        else if (dirKey === "backward") {
                            if (curFacing === '^') result = {char: 'v', dx: 0,  dy: 1,  isValid: true}; else if (curFacing === 'v') result = {char: '^', dx: 0,  dy: -1, isValid: true};
                            else if (curFacing === '<') result = {char: '>', dx: 1,  dy: 0,  isValid: true}; else if (curFacing === '>') result = {char: '<', dx: -1, dy: 0,  isValid: true};
                            else result.isValid = false; 
                        }
                    } else { result = {char: config.char, dx: config.dx, dy: config.dy, isValid: true}; }
                    return result;
                }
            } return result; 
        }
        commandInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') { event.preventDefault();
                if (typeof commandForm.requestSubmit === 'function') commandForm.requestSubmit();
                else { const sb = commandForm.querySelector('button[type="submit"]'); if (sb) sb.click(); }
            }
        });
        
        commandForm.addEventListener('submit', (event) => {
            event.preventDefault(); if (!selfPlayer) { addLogMessage("Not fully manifest!", 'event-bad'); return; }
            const inputText = commandInput.textContent.trim(); commandInput.innerHTML = ''; if (!inputText) return;
            const parts = inputText.split(/\s+/); let actionWord = parts[0];
            let messageContent = parts.length > 1 ? parts.slice(1).join(' ') : null;
            
            if (actionWord.startsWith("'") && actionWord.length >=1) { messageContent = (actionWord.substring(1) + (messageContent ? " " + messageContent : "")).trim(); actionWord = "say"; }
            else if (actionWord.startsWith("!") && actionWord.length >=1) { messageContent = (actionWord.substring(1) + (messageContent ? " " + messageContent : "")).trim(); actionWord = "shout"; }
            addLogMessage(`Tome jots down: ${actionWord}${messageContent ? ' ' + messageContent : ''}`, 'user-input');
            
            const canonicalAction = parseAction(actionWord);
            if (!canonicalAction) { logRandomizedEvent('ACTION_SENT_FEEDBACK', 'ACTION_FAILED_UNKNOWN_COMMAND', { actionWord: actionWord }, 'event-bad'); commandInput.focus(); return; }
            
            let commandToSend = { type: canonicalAction, details: {} }; let shouldEmitToServer = true; 
            
            if (canonicalAction === "move") { 
                const eTW = messageContent || "forward"; const dR = parseDirection(eTW, selfPlayer.char);
                if (dR.isValid) commandToSend.details = { dx: dR.dx, dy: dR.dy, newChar: dR.char };
                else { addLogMessage(`Tome frowns: Cannot move towards "${eTW}".`, 'event-bad'); shouldEmitToServer = false; }
            } else if (canonicalAction === "look") {
                const lookDirectionStr = messageContent || get_direction_str_from_dx_dy(...get_dx_dy_from_direction_str(selfPlayer.char)); // Default to current facing
                const dR = parseDirection(lookDirectionStr, selfPlayer.char);

                if (dR.isValid) {
                    // If just "look" with no args, or looking in current direction, don't send to server.
                    // Only send if they specified a NEW direction to look.
                    const currentFacingDxDy = get_dx_dy_from_direction_str(selfPlayer.char);
                    if (messageContent && (dR.dx !== currentFacingDxDy[0] || dR.dy !== currentFacingDxDy[1])) {
                        commandToSend.details = { dx: 0, dy: 0, newChar: dR.char };
                    } else { // Client-side only look
                        shouldEmitToServer = false; 
                        // Log what is seen client-side immediately for "look" in current direction
                        // or if server isn't being interacted with for this specific look.
                        let foundSomethingVisible = false;
                        const facingCharForLook = messageContent ? dR.char : selfPlayer.char;

                        if (visibleNPCs) {
                            for(const npc of visibleNPCs) {
                                if (isVisible(selfPlayer.x, selfPlayer.y, facingCharForLook, npc.x, npc.y)) {
                                    if(npc.char === PIXIE_CHAR_CLIENT) { 
                                         logRandomizedEvent('LORE', 'SEES_PIXIE_NEARBY', {pixieName: showDebugInfo ? npc.name : "a Mana Pixie"}, 'sensory-sight');
                                         foundSomethingVisible = true;
                                    }
                                }
                            }
                        }
                        for(const id in otherPlayers) {
                            const otherP = otherPlayers[id];
                             if (isVisible(selfPlayer.x, selfPlayer.y, facingCharForLook, otherP.x, otherP.y)) {
                                logRandomizedEvent('LORE', 'PLAYER_ARRIVES', {playerName: otherP.name}, 'system'); 
                                foundSomethingVisible = true;
                            }
                        }
                        if (!foundSomethingVisible) {
                            if (messageContent) { 
                                logRandomizedEvent('LORE', 'LOOK_DIRECTION_EMPTY', {direction: getDirectionWord(dR.char)}, 'system');
                            } else { 
                                logRandomizedEvent('LORE', 'LOOK_AROUND_EMPTY', {}, 'system');
                            }
                        }
                    }
                } else { 
                    addLogMessage(`Tome squints: Cannot look towards "${lookDirectionStr}".`, 'event-bad'); 
                    shouldEmitToServer = false; 
                }
            } else if (canonicalAction === "help") { 
                 addLogMessage("Tome patiently explains:\nMOVE: 'move [direction]' (n,s,e,w,fwd,back)\nLOOK: 'look [direction]'\nBUILD: 'build [direction]' or 'build' (in front)\nDESTROY: 'destroy [direction]' or 'destroy' (in front)\nCAST: 'cast [spell] [direction]'\nDRINK: 'drink potion'\nSAY: 'say [message]' or '[message]\nSHOUT: 'shout [message]' or ![message]", 'system'); 
                 shouldEmitToServer = false; 
            }
            else if (canonicalAction === "build") {
                commandToSend.type = 'build_wall';
                const targetDirStr = messageContent || "forward";
                const dirResult = parseDirection(targetDirStr, selfPlayer.char);
                if (dirResult.isValid) {
                    commandToSend.details = { dx: dirResult.dx, dy: dirResult.dy };
                } else {
                    addLogMessage(`Tome puzzles: Cannot determine direction to build "${targetDirStr}".`, 'event-bad');
                    shouldEmitToServer = false;
                }
            }
            else if (canonicalAction === "destroy") {
                commandToSend.type = 'destroy_wall';
                const targetDirStr = messageContent || "forward";
                const dirResult = parseDirection(targetDirStr, selfPlayer.char);
                if (dirResult.isValid) {
                    commandToSend.details = { dx: dirResult.dx, dy: dirResult.dy };
                } else {
                    addLogMessage(`Tome puzzles: Cannot determine direction to destroy "${targetDirStr}".`, 'event-bad');
                    shouldEmitToServer = false;
                }
            }
            else if (canonicalAction === "cast") { 
                 if (messageContent) commandToSend.details = { spellName: messageContent.split(' ')[0], targetDirection: messageContent.split(' ').length > 1 ? messageContent.split(' ')[1] : null }; 
                 else { addLogMessage(`Tome asks: Cast what, O Wizard?`, 'event-bad'); shouldEmitToServer = false; }
            } else if (canonicalAction === "drink") {
                if (messageContent && !(messageContent.toLowerCase().includes("potion"))) { addLogMessage(`Tome queries: Drink what specifically? (Try 'drink potion')`, 'event-bad'); shouldEmitToServer = false; }
                else commandToSend.type = 'drink_potion'; 
            } else if (canonicalAction === "say" || canonicalAction === "shout") {
                if (messageContent && messageContent.length > 0) commandToSend.details = { message: messageContent };
                else { addLogMessage(`Tome asks: ${canonicalAction.charAt(0).toUpperCase() + canonicalAction.slice(1)} what, O Wizard?`, 'event-bad'); shouldEmitToServer = false; }
            } else { addLogMessage(`The arcane art of "${canonicalAction}" is unknown.`, 'event-bad'); shouldEmitToServer = false; }
            
            if (shouldEmitToServer) { console.log("Emitting 'queue_player_action':", commandToSend); socket.emit('queue_player_action', commandToSend); }
            commandInput.focus();
        });

        window.toggleRainDebug = function() { 
            const wasRaining = globalWeather.isRaining; globalWeather.isRaining = !globalWeather.isRaining;
             if (currentSceneData.InsideID === 0) { 
                if (globalWeather.isRaining && !wasRaining) { if(showDebugInfo) addLogMessage("Tome shivers (DEBUG): The skies open...", "system"); }
                else if (!globalWeather.isRaining && wasRaining) { if(showDebugInfo) addLogMessage("Tome brightens (DEBUG): The rain subsides...", "system"); }
            } updateWeatherEffects();
        };
        window.toggleInsideDebug = function() { 
            currentSceneData.InsideID = currentSceneData.InsideID === 0 ? 1 : 0;
            currentSceneData.name = currentSceneData.InsideID === 0 ? "The Overworld (Debug)" : "A Cozy Hut (Debug)"; 
            if(showDebugInfo) addLogMessage(`Tome notes (DEBUG): You are now ${currentSceneData.InsideID === 0 ? 'Outdoors' : 'Indoors ('+currentSceneData.name+')'}.`, "system");
            updateStatus(); updateWeatherEffects();
        };
        
        initializeTheme(); 
        estimateCharacterSize("initial_page_load"); 
        drawGrid(); 
        
        if (commandInput) { commandInput.focus(); }
        const savedDebugInfoOnLoad = localStorage.getItem('showDebugInfo'); 
        showDebugInfo = savedDebugInfoOnLoad !== null ? JSON.parse(savedDebugInfoOnLoad) : false; 
        debugInfoToggle.checked = showDebugInfo; 
        rainIntensityControl.style.display = showDebugInfo ? 'block' : 'none';
        simulateTickControl.style.display = showDebugInfo ? 'block' : 'none'; // Initial state based on debugInfo
        
        const savedSimulateTick = localStorage.getItem('simulateServerTick');
        if (showDebugInfo && savedSimulateTick !== null) { // Only load if debug info is also on
            simulateTickToggle.checked = JSON.parse(savedSimulateTick);
            simulateServerTickEnabled = simulateTickToggle.checked;
            if (simulateServerTickEnabled && !simulatedTickInterval) {
                 simulatedTickInterval = setInterval(() => {
                    if (tickIndicator) { tickIndicator.classList.add('tick-flash'); if(tickFlashTimeout) clearTimeout(tickFlashTimeout); tickFlashTimeout = setTimeout(() => { if(tickIndicator) tickIndicator.classList.remove('tick-flash'); }, 150); }
                    if (selfPlayer) { drawGrid(); }
                }, GAME_TICK_RATE * 1000);
            }
        }


        updateStatus("Awaiting connection to the Ethereal Plane..."); 
        updateWeatherEffects(); 
        logRandomizedEvent('LORE', 'WELCOME_INITIAL', {}, 'welcome-message');

    </script>
</body>
</html>