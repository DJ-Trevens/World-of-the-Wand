<!DOCTYPE html>
<html lang = "en">
<head>
    <meta charset = "UTF-8">
    <meta name = "viewport" content = "width = device-width, initial-scale = 1.0">
    <title>World of the Wand</title>
    <link rel = "stylesheet" href = "{{url_for('game.static', filename = 'style.css')}}">

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
        const socket = io({path: "/world-of-the-wand/socket.io"});
    </script>
</head>
<body>
    <div id = "commandLog"></div>
    <!-- Container for game canvas and rain overlay -->
    <div id="gameCanvasContainer">
        <div id = "gameCanvas"> Summoning World... </div>
        <div id="rainOverlay"></div> <!-- Rain will be dynamically added here -->
    </div>
    <div id = "mainHeaderStatus"> Pondering the Ethereal Wave... </div>

    <div id = "commandInputBox">
        <form id = "commandForm">
            <label for = "commandText">Your will, Wizard?</label>
            <div id = "commandText" contenteditable = "true" spellcheck = "false" autocomplete = "off" role = "textbox" aria-multiline = "false"></div>
            <button type = "submit">Commit</button>
        </form>
    </div>

    <script>
        const gameCanvas = document.getElementById('gameCanvas');
        const gameCanvasContainer = document.getElementById('gameCanvasContainer');
        const rainOverlay = document.getElementById('rainOverlay');
        const mainHeaderStatus = document.getElementById('mainHeaderStatus');
        const commandLog = document.getElementById('commandLog');
        const commandForm = document.getElementById('commandForm');
        const commandInput = document.getElementById('commandText');

        let selfPlayer = null;
        let otherPlayers = {};
        let myPlayerID = null;
        let GRID_WIDTH = 25;
        let GRID_HEIGHT = 20;
        let GAME_TICK_RATE = 2.0;
        let prevSelfPlayerState = null;

        // --- Weather and Scene State (Client-Side Simulation) ---
        let currentSceneData = {
            InsideID: 0, // 0 = outdoors, positive numbers for different indoor areas
            name: "The Whispering Plains" // Example scene name
        };
        let globalWeather = {
            isRaining: false,
            intensity: 0.6 // 0.1 (light) to 1.0 (heavy)
        };
        let rainInterval = null;
        // --- End Weather and Scene State ---


        const FOG_CHAR = 'â–’';
        const FLOOR_CHAR = '.';
        const OBSERVABLE_DEPTH = 7;
        const OBSERVABLE_WIDTH = 1.0;
        const AURA_VISION_RANGE = 1;

        function get_dx_dy_from_direction_str(s) {
            const mapping = {'^': [0, -1], 'v': [0, 1], '<': [-1, 0], '>': [1, 0]};
            return mapping[s] || [0, 0];
        }

        function get_direction_str_from_dx_dy(dx, dy) {
            const mapping = {"0,-1": '^', "0,1": 'v', "-1,0": '<', "1,0": '>'};
            return mapping[`${dx},${dy}`];
        }

        function getRelativeCoords(playerX, playerY, playerFacingChar, targetX, targetY) {
            const worldDX = targetX - playerX;
            const worldDY = targetY - playerY;
            let pf;
            if (playerFacingChar === '^') pf = 'n';
            else if (playerFacingChar === 'v') pf = 's';
            else if (playerFacingChar === '<') pf = 'w';
            else if (playerFacingChar === '>') pf = 'e';
            else return { rx: worldDX, ry: worldDY };

            if (pf === 'n') return {rx: worldDX, ry: worldDY};
            if (pf === 's') return {rx: -worldDX, ry: -worldDY};
            if (pf === 'w') return {rx: -worldDY, ry: worldDX};
            if (pf === 'e') return {rx: worldDY, ry: -worldDX};
            return { rx: worldDX, ry: worldDY };
        }

        function manhattanDistance(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) + Math.abs(y1 - y2);
        }

        function isVisible(observerX, observerY, observerChar, targetX, targetY, scry = false) {
            if (!observerChar) return false;
            let manhattanDist = manhattanDistance(observerX, observerY, targetX, targetY);
            if (scry || manhattanDist <= AURA_VISION_RANGE) return true;

            const {rx, ry} = getRelativeCoords(observerX, observerY, observerChar, targetX, targetY);
            const worldDX = targetX - observerX;
            const worldDY = targetY - observerY;

            if (manhattanDist === 2 && Math.abs(worldDX) === 1 && Math.abs(worldDY) === 1 && rx <= 0) return true;
            if (ry < 0 && -ry <= OBSERVABLE_DEPTH && Math.abs(rx) <= Math.floor(-ry * OBSERVABLE_WIDTH)) return true;
            return false;
        }

        function addLogMessage(message, type = 'lore') {
            const logEntry = document.createElement('div');
            logEntry.classList.add('log-entry', `log-${type}`);
            logEntry.textContent = message;
            commandLog.appendChild(logEntry);
            commandLog.scrollTop = commandLog.scrollHeight;
        }

        function updateStatus(status) {
            if (status) {
                mainHeaderStatus.textContent = status;
            } else if (selfPlayer) {
                mainHeaderStatus.textContent = `Scene: (${selfPlayer.scene_x}, ${selfPlayer.scene_y}) ${currentSceneData.name} (${currentSceneData.InsideID === 0 ? 'Outdoors' : 'Indoors ID:'+currentSceneData.InsideID }) | ${selfPlayer.char}: (${selfPlayer.x}, ${selfPlayer.y}) | Mana: 175/175 | Wand: 100%`;
            } else {
                mainHeaderStatus.textContent = "Awaiting Your Manifestation...";
            }
        }

        function drawGrid() {
            if (!selfPlayer || GRID_WIDTH === 0 || GRID_HEIGHT === 0) {
                gameCanvas.textContent = "The mists obscure your vision... (Awaiting server data)";
                return;
            }
            let displayGrid = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(FLOOR_CHAR));
            
            for (const playerID in otherPlayers) {
                const otherGuy = otherPlayers[playerID];
                if (otherGuy.scene_x === selfPlayer.scene_x && otherGuy.scene_y === selfPlayer.scene_y) {
                    if (otherGuy.x >= 0 && otherGuy.x < GRID_WIDTH && otherGuy.y >= 0 && otherGuy.y < GRID_HEIGHT) {
                        displayGrid[otherGuy.y][otherGuy.x] = otherGuy.char;
                    }
                }
            }
            if (selfPlayer.x >= 0 && selfPlayer.x < GRID_WIDTH && selfPlayer.y >= 0 && selfPlayer.y < GRID_HEIGHT) {
                displayGrid[selfPlayer.y][selfPlayer.x] = selfPlayer.char;
            }

            let output = "";
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (isVisible(selfPlayer.x, selfPlayer.y, selfPlayer.char, x, y)) {
                        output += displayGrid[y][x];
                    } else {
                        output += FOG_CHAR;
                    }
                }
                output += "\n";
            }
            gameCanvas.textContent = output;
        }

        // --- Weather Effect Functions ---
        function startRainEffect(intensity) {
            if (rainInterval) clearInterval(rainInterval); // Clear existing interval if any
            rainOverlay.innerHTML = ''; // Clear old raindrops

            const containerHeight = rainOverlay.offsetHeight; // Use actual height for fall animation

            // Adjust drop creation rate based on intensity
            const dropsPerSecond = 5 + (intensity * 25); // e.g., 5 to 30 drops/sec
            rainInterval = setInterval(() => {
                const drop = document.createElement('div');
                drop.classList.add('raindrop');
                drop.style.left = Math.random() * 100 + '%';
                
                // Vary animation duration for a more natural look
                const duration = 0.5 + Math.random() * 0.5; // 0.5s to 1s fall time
                drop.style.animationDuration = duration + 's';
                
                // Adjust fall distance based on container height for the keyframes
                // This requires dynamic keyframes or a trick. Simpler: animate to a large fixed value.
                // The @keyframes 'fall' uses translateY(calc(100vh + 50px)), which might be too large/small
                // A better way for dynamic height is to use JS to set the end translateY.
                // For simplicity now, the CSS keyframe is generic.

                rainOverlay.appendChild(drop);

                // Remove drop after it finishes animation
                drop.addEventListener('animationend', () => {
                    drop.remove();
                });
            }, 1000 / dropsPerSecond);
        }

        function stopRainEffect() {
            if (rainInterval) clearInterval(rainInterval);
            rainInterval = null;
            // Existing drops will finish their animation and be removed by their own event listeners
            // Optionally, remove all immediately: rainOverlay.innerHTML = '';
        }

        function updateWeatherEffects() {
            // Adjust gameCanvasContainer height for rainOverlay if gameCanvas size changes
            // This is a bit tricky if gameCanvas size is purely by content.
            // For now, assuming rainOverlay correctly covers gameCanvas via its parent.
             gameCanvasContainer.style.height = gameCanvas.offsetHeight + 'px';
             gameCanvasContainer.style.width = gameCanvas.offsetWidth + 'px';


            if (globalWeather.isRaining && currentSceneData.InsideID === 0) {
                if (!rainInterval) { // Only start if not already raining (idempotency)
                    startRainEffect(globalWeather.intensity);
                }
            } else {
                if (rainInterval) { // Only stop if currently raining
                    stopRainEffect();
                }
            }
        }
        // --- End Weather Effect Functions ---

        socket.on('connect', () => {
            updateStatus("Divining your essence...");
        });

        socket.on('initial_state', (data) => {
            selfPlayer = data.player;
            myPlayerID = selfPlayer.id;
            GRID_WIDTH = data.grid_width;
            GRID_HEIGHT = data.grid_height;
            GAME_TICK_RATE = data.tick_rate;
            otherPlayers = data.other_players || {};
            prevSelfPlayerState = { ...selfPlayer };

            // Placeholder: Server should send currentSceneData and globalWeather
            // currentSceneData = data.sceneData || { InsideID: 0, name: "The Starting Plains" };
            // globalWeather = data.weatherData || { isRaining: false, intensity: 0.5 };

            if (otherPlayers[myPlayerID]) delete otherPlayers[myPlayerID];

            if (selfPlayer && typeof GRID_WIDTH === 'number' && GRID_WIDTH > 0) {
                updateStatus();
                drawGrid(); // Draw grid first
                updateWeatherEffects(); // Then update weather, which might need canvas dimensions
                addLogMessage(`Tome: You have materialized in ${currentSceneData.name} at scene (${selfPlayer.scene_x}, ${selfPlayer.scene_y}). The world awaits!`, 'lore');
            } else {
                addLogMessage("Tome warns: Error! Could not manifest in world.", 'event-bad');
            }
        });

        socket.on('player_joined', (newPlayer) => {
            if (myPlayerID && newPlayer.id !== myPlayerID && selfPlayer &&
                newPlayer.scene_x === selfPlayer.scene_x && newPlayer.scene_y === selfPlayer.scene_y) {
                otherPlayers[newPlayer.id] = newPlayer;
                drawGrid();
                addLogMessage("Tome notes: You sense the arrival of another sorcerer in this area.", 'event-good');
            }
        });

        socket.on('player_left', (playerID) => {
            if (otherPlayers[playerID]) {
                delete otherPlayers[playerID];
                drawGrid();
                addLogMessage("Tome records: A sorcerer has departed this area.", 'lore');
            }
        });
        
        socket.on('lore_message', (data) => {
            addLogMessage(data.message, data.type || 'lore');
        });

        socket.on('game_state_update', (allPlayers) => {
            let foundSelf = false;
            const currentOtherPlayersInMyScene = {};
            let previousInsideID = currentSceneData.InsideID; // Store before potential update

            for (const playerData of allPlayers) {
                if (playerData.id === myPlayerID) {
                    selfPlayer = playerData;
                    foundSelf = true;
                    // Placeholder: Server should send new scene data if scene_x/y changed
                    // For now, we assume currentSceneData.InsideID might change if player moves to a new pre-defined area.
                    // This part needs proper server integration for scene data.
                    // if (selfPlayer.scene_x !== prevSelfPlayerState.scene_x || selfPlayer.scene_y !== prevSelfPlayerState.scene_y) {
                    //    fetchNewSceneData(selfPlayer.scene_x, selfPlayer.scene_y); // Imaginary function
                    // }
                } else if (selfPlayer && playerData.scene_x === selfPlayer.scene_x && playerData.scene_y === selfPlayer.scene_y) {
                    currentOtherPlayersInMyScene[playerData.id] = playerData;
                }
            }
            otherPlayers = currentOtherPlayersInMyScene;

            if (!foundSelf && myPlayerID) {
                updateStatus("Your connection to this world wavers... (bad connection)");
                addLogMessage("Tome's script flickers: Warning! Your connection to self is unstable.", 'event-bad');
            }

            if (selfPlayer && prevSelfPlayerState) {
                const sceneCoordsChanged = selfPlayer.scene_x !== prevSelfPlayerState.scene_x || selfPlayer.scene_y !== prevSelfPlayerState.scene_y;
                
                if (sceneCoordsChanged) {
                    otherPlayers = {}; 
                    for (const playerData of allPlayers) {
                        if (playerData.id !== myPlayerID && playerData.scene_x === selfPlayer.scene_x && playerData.scene_y === selfPlayer.scene_y) {
                            otherPlayers[playerData.id] = playerData;
                        }
                    }
                    // Simulate fetching new scene data; for now, just log and maybe toggle InsideID for testing
                    // currentSceneData = getSceneDataFor(selfPlayer.scene_x, selfPlayer.scene_y); // Imaginary
                    addLogMessage(`Tome notes: You are now in scene (${selfPlayer.scene_x}, ${selfPlayer.scene_y}).`, 'system');
                } else { 
                    const movedLocal = selfPlayer.x !== prevSelfPlayerState.x || selfPlayer.y !== prevSelfPlayerState.y;
                    const turned = selfPlayer.char !== prevSelfPlayerState.char;

                    if (movedLocal) {
                        let facingDirectionWord = getDirectionWord(selfPlayer.char);
                        addLogMessage(`Tome traces your path: You move within scene (${selfPlayer.scene_x},${selfPlayer.scene_y}) to (${selfPlayer.x}, ${selfPlayer.y}), facing ${facingDirectionWord}.`, 'lore');
                    } else if (turned) {
                        let facingDirectionWord = getDirectionWord(selfPlayer.char);
                        addLogMessage(`Tome observes: You turn to face ${facingDirectionWord} at (${selfPlayer.x},${selfPlayer.y}) in scene (${selfPlayer.scene_x},${selfPlayer.scene_y}).`, 'lore');
                    }
                }
            }
            if (selfPlayer) prevSelfPlayerState = { ...selfPlayer };
            
            drawGrid();
            updateStatus(); 
            // Check if InsideID actually changed to update weather correctly
            // if (currentSceneData.InsideID !== previousInsideID || sceneCoordsChanged) {
            updateWeatherEffects(); // Always call to ensure rain overlay is sized correctly
            // }
        });

        function getDirectionWord(char) {
            if (char === '^') return "North"; if (char === 'v') return "South";
            if (char === '<') return "West";  if (char === '>') return "East";
            return "an unknown direction";
        }

        socket.on('action_queued', (data) => addLogMessage("Tome confirms: " + data.message, "system"));
        socket.on('action_failed', (data) => addLogMessage("Tome shakes its pages: " + data.message, 'event-bad'));
        
        socket.on('disconnect', () => {
            updateStatus("Severed from the Ethereal Plane! (Disconnected)");
            addLogMessage("Tome wails: Disconnected from the server! The weave unravels!", 'event-bad');
            selfPlayer = null; otherPlayers = {}; prevSelfPlayerState = null;
            stopRainEffect(); // Stop rain on disconnect
            drawGrid();
        });

        const ACTION_ALIASES = {
            "move": ["move", "go", "walk", "step", "head", "run"],
            "look": ["look", "face", "turn"],
            "cast": ["cast", "zap", "fire", "spell"],
            "help": ["help", "?"]
        };
        const DIRECTION_ALIASES = {
            "north":    {char: '^', dx: 0,  dy: -1, aliases: ["north", "n", "up"]},
            "south":    {char: 'v', dx: 0,  dy: 1,  aliases: ["south", "s", "down"]},
            "west":     {char: '<', dx: -1, dy: 0,  aliases: ["west", "w", "left", "lft", "l"]},
            "east":     {char: '>', dx: 1,  dy: 0,  aliases: ["east", "e", "right", "rght", "rgt", "r"]},
            "forward":  {relative: true, aliases: ["forward", "forwards", "fwd", "f", "ahead", "straight", "onward", "onwards"]},
            "backward": {relative: true, aliases: ["backward", "backwards", "back", "bck", "behind", "b"]},
        };

        function parseAction(actionWord) {
            actionWord = actionWord.toLowerCase();
            for (const canonicalAction in ACTION_ALIASES) {
                if (ACTION_ALIASES[canonicalAction].includes(actionWord)) return canonicalAction;
            }
            return null;
        }

        function parseDirection(directionStr, curFacing) {
            directionStr = directionStr.toLowerCase();
            let result = {char: curFacing, dx: 0, dy: 0, isValid: false};
            for (const dirKey in DIRECTION_ALIASES) {
                const config = DIRECTION_ALIASES[dirKey];
                if (config.aliases.includes(directionStr)) {
                    if (config.relative) {
                        result.isValid = true;
                        if (dirKey === "forward") {
                            result.char = curFacing;
                            const [dx, dy] = get_dx_dy_from_direction_str(curFacing);
                            result.dx = dx; result.dy = dy;
                            if (dx === 0 && dy === 0 && !['^','v','<','>'].includes(curFacing)) result.isValid = false;
                        } else if (dirKey === "backward") {
                            if      (curFacing === '^') result = {char: 'v', dx: 0,  dy: 1,  isValid: true};
                            else if (curFacing === 'v') result = {char: '^', dx: 0,  dy: -1, isValid: true};
                            else if (curFacing === '<') result = {char: '>', dx: 1,  dy: 0,  isValid: true};
                            else if (curFacing === '>') result = {char: '<', dx: -1, dy: 0,  isValid: true};
                            else result.isValid = false;
                        }
                    } else {
                        result = {char: config.char, dx: config.dx, dy: config.dy, isValid: true};
                    }
                    return result;
                }
            }
            return result;
        }

        commandInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                if (typeof commandForm.requestSubmit === 'function') {
                    commandForm.requestSubmit();
                } else { 
                    const submitButton = commandForm.querySelector('button[type="submit"]');
                    if (submitButton) submitButton.click();
                }
            }
        });

        commandForm.addEventListener('submit', (event) => {
            event.preventDefault();
            if (!selfPlayer) {
                addLogMessage("Tome whispers urgently: You are not fully manifest in this realm yet!", 'event-bad');
                return;
            }
            const inputText = commandInput.textContent.trim();
            commandInput.innerHTML = ''; // Clear input

            if (!inputText) return;
            addLogMessage(`> ${inputText}`, 'user-input');

            const parts = inputText.split(/\s+/);
            const actionWord = parts[0];
            const targetWord = parts.length > 1 ? parts.slice(1).join(' ') : null;
            const canonicalAction = parseAction(actionWord);

            if (!canonicalAction) {
                addLogMessage(`Tome seems puzzled: Your will "${actionWord}" is indecipherable. (Perhaps 'help' will illuminate the path?)`, 'event-bad');
                commandInput.focus(); return;
            }

            let commandToSend = { type: canonicalAction, details: {} };
            let shouldEmit = false;

            if (canonicalAction === "move") {
                const effectiveTargetWord = targetWord || "forward";
                const dirResult = parseDirection(effectiveTargetWord, selfPlayer.char);
                if (dirResult.isValid) {
                    const currentX = selfPlayer.x;
                    const currentY = selfPlayer.y;
                    const targetX_local = currentX + dirResult.dx;
                    const targetY_local = currentY + dirResult.dy;

                    if (targetX_local < 0 || targetX_local >= GRID_WIDTH || targetY_local < 0 || targetY_local >= GRID_HEIGHT) {
                        let directionOfExit = "";
                        if (targetX_local < 0) directionOfExit = "west";
                        else if (targetX_local >= GRID_WIDTH) directionOfExit = "east";
                        else if (targetY_local < 0) directionOfExit = "north";
                        else if (targetY_local >= GRID_HEIGHT) directionOfExit = "south";
                        addLogMessage(`Tome notes your intent: You attempt to venture further ${directionOfExit}, beyond the current parchment...`, 'system');
                    }
                    commandToSend.details = { dx: dirResult.dx, dy: dirResult.dy, newChar: dirResult.char };
                    shouldEmit = true;
                } else {
                    addLogMessage(`Tome frowns: You ponder moving towards "${effectiveTargetWord}", but the way is unclear.`, 'event-bad');
                }
            } else if (canonicalAction === "look") {
                const effectiveTargetWord = targetWord || "forward";
                const dirResult = parseDirection(effectiveTargetWord, selfPlayer.char);
                if (dirResult.isValid) {
                    commandToSend.details = { dx: 0, dy: 0, newChar: dirResult.char };
                    shouldEmit = true;
                    // Add client-side "look" description if server doesn't provide one immediately
                    addLogMessage(`Tome's gaze follows yours: You peer ${effectiveTargetWord}. The air is thick with untold stories.`, 'lore');

                } else {
                     addLogMessage(`Tome squints: You try to peer towards "${effectiveTargetWord}", but your vision blurs.`, 'event-bad');
                }
            } else if (canonicalAction === "help") {
                addLogMessage("Tome patiently explains: My pages are still being written for detailed help. For now, try 'move [direction]' (north, south, east, west, forward, backward) or 'look [direction]'. You can also try 'cast [spell name]'.", 'system');
            } else if (canonicalAction === "cast") {
                 if (targetWord) {
                    commandToSend.details = { spellName: targetWord }; 
                    shouldEmit = true;
                    addLogMessage(`Tome focuses: You begin to channel energy for "${targetWord}"...`, 'system');
                 } else {
                    addLogMessage(`Tome asks: Cast what, O Wizard? You must name the incantation.`, 'event-bad');
                 }
            } else {
                addLogMessage(`Tome sighs: The arcane art of "${canonicalAction}" is yet beyond your grasp, or perhaps my understanding.`, 'event-bad');
            }

            if (shouldEmit) {
                socket.emit('queue_command', commandToSend);
            }
            commandInput.focus();
        });
        
        // Debug function to toggle rain
        window.toggleRainDebug = function() {
            globalWeather.isRaining = !globalWeather.isRaining;
            if (globalWeather.isRaining) {
                addLogMessage("Tome shivers (DEBUG): The skies open and a steady rain begins to fall.", "system");
            } else {
                addLogMessage("Tome brightens (DEBUG): The rain subsides, leaving the air fresh.", "system");
            }
            updateWeatherEffects();
        };
         window.toggleInsideDebug = function() {
            currentSceneData.InsideID = currentSceneData.InsideID === 0 ? 1 : 0;
            addLogMessage(`Tome notes (DEBUG): You are now ${currentSceneData.InsideID === 0 ? 'Outdoors' : 'Indoors'}.`, "system");
            updateStatus();
            updateWeatherEffects();
        };


        // Initial setup
        drawGrid();
        if (commandInput) { commandInput.focus(); }
        updateWeatherEffects(); // Initialize weather effects based on default state
        addLogMessage("Tome unfurls its pages: Welcome, Wizard. The Ethereal Waves await your command.", 'system');

    </script>
</body>
</html>