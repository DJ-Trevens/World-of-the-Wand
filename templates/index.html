<!DOCTYPE html>
<html lang = "en">
<head>
    <meta charset = "UTF-8">
    <meta name = "viewport" content = "width = device-width, initial-scale = 1.0, user-scalable=no">
    <title>World of the Wand - Tome of Echoes</title>
    <link rel = "stylesheet" href = "{{url_for('game.static', filename = 'style.css')}}">

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script src="{{url_for('game.static', filename='game_texts.js')}}"></script> 
    <script>
        const socket = io({path: "/world-of-the-wand/socket.io"});
    </script>
</head>
<body> 
    <div class="main-ui-container">
        <div class="left-panel"> 
            <div id="commandLog"></div>
            <div id="commandInputBox">
                <form id="commandForm">
                    <label for="commandText">
                         Inscribe Your Will:
                    </label>
                    <div id="commandText" contenteditable="true" spellcheck="false" autocomplete="off" role="textbox" aria-multiline="false"></div>
                    <button type="submit">Enact</button>
                </form>
            </div>
        </div>

        <div class="right-panel">
            <div id="mainHeaderStatusContainer">
                <div id="mainHeaderStatus">World of the Wand</div>
            </div>

            <div id="gameCanvasContainer">
                <canvas id="gameCanvas">Your browser does not support the canvas element.</canvas>
                <div id="rainOverlay"></div>
            </div>
            
            <div id="bottomRightPanelOuter"> 
                <div class="debug-master-toggle">
                     <label>
                        <input type="checkbox" id="debugInfoToggle"> Show Debug Panel
                    </label>
                </div>
                <div id="debugAndAuxiliaryPanel" class="info-panel" style="display:none;"> 
                    <hr class="debug-hr">
                    <div class="debug-panel-container"> 
                        <div class="debug-info-side">
                            <h4>Debug Stats</h4> 
                            <div id="clientDebugInfo"> 
                                <div>Self: <span id="dbgSelfPlayer">N/A</span></div>
                                <div>Others: <span id="dbgOtherPlayersCount">0</span></div>
                                <div>NPCs: <span id="dbgNpcsCount">0</span></div>
                                <div>
                                    <span id="serverHeartbeatIndicator" class="heartbeat-indicator-inline"></span> Server Heartbeat: <span id="dbgLastUpdate">Never</span>
                                </div>
                                <div>
                                    <span id="simulatedHeartbeatIndicator" class="heartbeat-indicator-inline"></span> Sim. Heartbeat: <span id="dbgSimulating">false</span>
                                </div>
                            </div>
                        </div>
                        <div class="debug-config-side">
                            <h4>Debug Config:</h4>
                            <div id="rainIntensityControl" class="debug-control-item">
                                <label>
                                    Rain: <input type="range" id="rainIntensitySlider" min="0" max="1" step="0.05">
                                </label>
                            </div>
                            <div id="simulateHeartbeatControl" class="debug-control-item">
                                 <label>
                                    <input type="checkbox" id="simulateHeartbeatToggle"> Simulate Client Heartbeat 
                                </label>
                            </div>
                            <div class="debug-control-item">
                                 <button id="themeToggle" title="Switch to Light Mode">‚òÄÔ∏è</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d');
        const gameCanvasContainer = document.getElementById('gameCanvasContainer');
        const rainOverlay = document.getElementById('rainOverlay');
        const mainHeaderStatus = document.getElementById('mainHeaderStatus');
        const commandLog = document.getElementById('commandLog');
        const commandForm = document.getElementById('commandForm');
        const commandInput = document.getElementById('commandText');
        
        const serverHeartbeatIndicator = document.getElementById('serverHeartbeatIndicator'); 
        const simulatedHeartbeatIndicator = document.getElementById('simulatedHeartbeatIndicator');
        const debugInfoToggle = document.getElementById('debugInfoToggle');
        const rainIntensitySlider = document.getElementById('rainIntensitySlider');
        const rainIntensityControl = document.getElementById('rainIntensityControl');
        const themeToggleButton = document.getElementById('themeToggle');
        const simulateHeartbeatToggle = document.getElementById('simulateHeartbeatToggle'); 
        const simulateHeartbeatControl = document.getElementById('simulateHeartbeatControl'); 
        const clientDebugInfo = document.getElementById('clientDebugInfo'); 
        const debugAndAuxiliaryPanel = document.getElementById('debugAndAuxiliaryPanel'); 

        const dbgSelfPlayer = document.getElementById('dbgSelfPlayer');
        const dbgOtherPlayersCount = document.getElementById('dbgOtherPlayersCount');
        const dbgNpcsCount = document.getElementById('dbgNpcsCount');
        const dbgLastUpdate = document.getElementById('dbgLastUpdate');
        const dbgSimulating = document.getElementById('dbgSimulating');

        const MOON_EMOJI = 'üåô'; 
        const SUN_EMOJI = '‚òÄÔ∏è'; 

        let showDebugInfoState = true; 
        let selfPlayer = null;
        let otherPlayers = {}; 
        let visibleNPCs = [];
        let visibleTerrain = { walls: [], water: [] }; 
        let myPlayerID = null; 
        let GRID_WIDTH = 20; 
        let GRID_HEIGHT = 15;
        let GAME_HEARTBEAT_RATE = 0.75; 
        let prevSelfPlayerState = null;
        let currentSceneData = { InsideID: 0, name: "The Whispering Plains" }; 
        let globalWeather = { isRaining: true, intensity: 0.25 }; 
        let rainInterval = null;
        const RAIN_INTERVAL_DELAY = 50; 
        let isDragging = false;
        let startDragX, startDragY;
        let currentPanX = 0; 
        let currentPanY = 0;   
        
        const DEFAULT_FONT_SIZE_PX = 18;
        const X_STRETCH_FACTOR = 1.15; 
        const DEFAULT_CHAR_WIDTH_FALLBACK = (DEFAULT_FONT_SIZE_PX * 0.6) * X_STRETCH_FACTOR;
        const DEFAULT_CHAR_HEIGHT_FALLBACK = DEFAULT_FONT_SIZE_PX * 0.9; 
        
        let charRenderWidth = DEFAULT_CHAR_WIDTH_FALLBACK; 
        let charRenderHeight = DEFAULT_CHAR_HEIGHT_FALLBACK; 
        let charSizeEstimatedAtLeastOnce = false;
        let initialCenteringDone = false;
        let initialUIDone = false; 

        const FOG_CHAR = '‚ñí';    
        const FLOOR_CHAR = '¬∑';  
        const WALL_CHAR = '‚ñì';   
        const WATER_CHAR = '~'; 
        const PIXIE_CHAR_CLIENT = '*';
        const AURA_VISION_RANGE = 1;

        let currentGameZoomFactor = 1.4; 
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 3.0;
        const ZOOM_INCREMENT = 0.05; // Made zoom finer

        let simulateServerHeartbeatEnabled = false; 
        let simulatedHeartbeatInterval = null;     
        let serverHeartbeatFlashTimeout = null; 
        let simulatedHeartbeatFlashTimeout = null; 


        function updateGameTransform() {
            // This function solely applies the current pan and zoom to the canvas.
            // It does NOT calculate where to pan/zoom to.
            gameCanvas.style.transform = `translate(${currentPanX}px, ${currentPanY}px) scale(${currentGameZoomFactor})`;
        }
        
        function applyTheme(theme) {
            if (theme === 'light') {
                document.body.classList.add('light-theme');
                document.body.classList.remove('dark-theme');
                themeToggleButton.textContent = MOON_EMOJI;
                themeToggleButton.title = "Switch to Dark Mode";
            } else { 
                document.body.classList.add('dark-theme'); 
                document.body.classList.remove('light-theme');
                themeToggleButton.textContent = SUN_EMOJI;
                themeToggleButton.title = "Switch to Light Mode";
            }
            localStorage.setItem('worldOfTheWandTheme', theme);
            if(selfPlayer && charSizeEstimatedAtLeastOnce) drawGrid();
        }

        function toggleTheme() {
            const currentThemeIsDark = document.body.classList.contains('dark-theme');
            applyTheme(currentThemeIsDark ? 'light' : 'dark');
        }
        themeToggleButton.addEventListener('click', toggleTheme);

        function initializeTheme() {
            const savedTheme = localStorage.getItem('worldOfTheWandTheme');
            if (savedTheme) { applyTheme(savedTheme); } 
            else { applyTheme(window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark'); }
        }
        
        function get_dx_dy_from_direction_str(s) { 
            const mapping = {'^': [0, -1], 'v': [0, 1], '<': [-1, 0], '>': [1, 0]};
            return mapping[s] || [0, 0];
        }
        function get_direction_str_from_dx_dy(dx, dy) { 
            const mapping = {"0,-1": '^', "0,1": 'v', "-1,0": '<', "1,0": '>'};
            return mapping[`${dx},${dy}`];
        }
        function getRelativeCoords(playerX, playerY, playerFacingChar, targetX, targetY) { 
            const worldDX = targetX - playerX; const worldDY = targetY - playerY;
            let pf;
            if (playerFacingChar === '^') pf = 'n'; else if (playerFacingChar === 'v') pf = 's';
            else if (playerFacingChar === '<') pf = 'w'; else if (playerFacingChar === '>') pf = 'e';
            else return { rx: worldDX, ry: worldDY };
            if (pf === 'n') return {rx: worldDX, ry: worldDY}; if (pf === 's') return {rx: -worldDX, ry: -worldDY};
            if (pf === 'w') return {rx: -worldDY, ry: worldDX}; if (pf === 'e') return {rx: worldDY, ry: -worldDX};
            return { rx: worldDX, ry: worldDY };
        }
        function manhattanDistance(x1, y1, x2, y2) { return Math.abs(x1 - x2) + Math.abs(y1 - y2); }
        
        function isVisible(observerX, observerY, observerChar, targetX, targetY, scry = false) { 
            if (!observerChar || !selfPlayer) return false; 
            let manhattanDist = manhattanDistance(observerX, observerY, targetX, targetY);
            if (scry || manhattanDist <= AURA_VISION_RANGE) return true;
            
            const {rx, ry} = getRelativeCoords(observerX, observerY, observerChar, targetX, targetY);
            const clientObservableDepth = 10; 
            const OBSERVABLE_WIDTH_CONST = 1.0; 
            
            if (ry < 0 && -ry <= clientObservableDepth && Math.abs(rx) <= Math.floor(-ry * OBSERVABLE_WIDTH_CONST )) return true;
            
            return false;
        }

        function addLogMessage(message, type = 'lore') { 
            const logEntry = document.createElement('div');
            let displayStyle = 'ink';
            switch (type) {
                case 'event-bad': case 'chat-shout': case 'server-major-event': 
                case 'player-trade': case 'player-damage': case 'welcome-message': 
                case 'sensory-magic': 
                    displayStyle = 'mana'; break;
                case 'sensory-sound': case 'sensory-smell': case 'sensory-sight':
                case 'system': case 'event-good': case 'spell-cast': 
                case 'lore': case 'user-input': case 'chat-say':          
                default: displayStyle = 'ink'; break;
            }
            logEntry.classList.add('log-entry', `log-style-${displayStyle}`, `log-type-${type}`);
            logEntry.textContent = message; 
            commandLog.appendChild(logEntry);
            requestAnimationFrame(() => { commandLog.scrollTop = commandLog.scrollHeight; });
        }
        function logRandomizedEvent(mainKey, subKey, placeholders = {}, messageType = 'lore') { 
            const message = getRandomGameText(mainKey, subKey, placeholders);
            addLogMessage(message, messageType);
        }
        function updateStatus(statusText) { 
            if (statusText) {
                mainHeaderStatus.textContent = statusText;
            } else if (selfPlayer) {
                let healthPercentage = selfPlayer.max_health > 0 ? Math.round((selfPlayer.current_health / selfPlayer.max_health) * 100) : 0;
                let baseStatus = `${healthPercentage}% Health | ${selfPlayer.current_mana} Mana`;
                if (showDebugInfoState) { 
                     baseStatus += `/${selfPlayer.max_mana}`;
                }
                baseStatus += ` | ${selfPlayer.gold || 0} Gold | ${selfPlayer.potions} Potions | ${selfPlayer.walls} Walls`;
                
                if (showDebugInfoState) {
                    let locationType = currentSceneData.InsideID === 0 ? 'Outdoors' : `Indoors (ID:${currentSceneData.InsideID})`; 
                     mainHeaderStatus.textContent = `Scene: (${selfPlayer.scene_x},${selfPlayer.scene_y}) ${currentSceneData.name} [${locationType}] | ${selfPlayer.char}:(${selfPlayer.x},${selfPlayer.y}) ${selfPlayer.is_wet ? '(Wet)' : ''} | ${baseStatus}`;
                } else {
                    mainHeaderStatus.textContent = baseStatus;
                }
            } else {
                mainHeaderStatus.textContent = "Connecting to the World of the Wand...";
            }
        }
        
        function estimateCharacterSize(context = "unknown") { 
            const testChar = 'M'; 
            const computedStyle = getComputedStyle(document.documentElement);
            const fontFamily = computedStyle.getPropertyValue('--font-game').trim() || "'Courier New', monospace";
            const fontSize = DEFAULT_FONT_SIZE_PX + "px";
            const tempSpan = document.createElement('span');
            tempSpan.style.fontFamily = fontFamily;
            tempSpan.style.fontSize = fontSize;
            tempSpan.style.lineHeight = computedStyle.getPropertyValue('line-height') || String(DEFAULT_FONT_SIZE_PX * 0.9);
            tempSpan.style.whiteSpace = 'pre';
            tempSpan.style.visibility = 'hidden';
            tempSpan.style.position = 'absolute';
            tempSpan.textContent = testChar;
            document.body.appendChild(tempSpan);
            let measuredWidth = tempSpan.offsetWidth;
            let measuredHeight = tempSpan.offsetHeight;
            document.body.removeChild(tempSpan);

            if (measuredWidth > 0 && measuredHeight > 0) {
                charRenderWidth = measuredWidth * X_STRETCH_FACTOR; 
                charRenderHeight = measuredHeight;
            } else {
                charRenderWidth = DEFAULT_CHAR_WIDTH_FALLBACK; 
                charRenderHeight = DEFAULT_CHAR_HEIGHT_FALLBACK;
            }
            
            if (GRID_WIDTH > 0 && GRID_HEIGHT > 0 && charRenderWidth > 0 && charRenderHeight > 0) {
                gameCanvas.width = GRID_WIDTH * charRenderWidth;
                gameCanvas.height = GRID_HEIGHT * charRenderHeight;
            }
            charSizeEstimatedAtLeastOnce = true; 
            console.log(`[estimateCharacterSize context: ${context}] Char WxH: ${charRenderWidth.toFixed(2)}x${charRenderHeight.toFixed(2)}. Canvas WxH: ${gameCanvas.width}x${gameCanvas.height}`);
        }

        function drawGrid() { /* ... (No changes to drawGrid content itself from last full version) ... */ }

        function startRainEffect(intensity) { /* ... (No change) ... */ }
        function stopRainEffect() { /* ... (No change) ... */ }
        function updateWeatherEffects() { /* ... (No change) ... */ }
        
        // Drag to Pan Logic
        gameCanvasContainer.addEventListener('mousedown', (e) => { 
            if (e.button !== 0) return; 
            isDragging = true; document.body.classList.add('is-dragging');
            gameCanvasContainer.style.cursor = 'grabbing';
            const rect = gameCanvas.getBoundingClientRect(); // Get current scale and transform from CSS
            // Calculate start drag relative to the current pan and zoom
            startDragX = e.clientX - currentPanX; 
            startDragY = e.clientY - currentPanY;
            gameCanvas.style.transition = 'none'; 
        });
        window.addEventListener('mousemove', (e) => { 
            if (!isDragging) return;
            currentPanX = e.clientX - startDragX; 
            currentPanY = e.clientY - startDragY;
            updateGameTransform();
        });
        window.addEventListener('mouseup', (e) => { 
            if (e.button !== 0 || !isDragging) return;
            isDragging = false; document.body.classList.remove('is-dragging');
            gameCanvasContainer.style.cursor = 'grab';
            // No need to re-apply transition if it's always on for transform
            // gameCanvas.style.transition = 'transform 0.3s ease-out'; 
        });
        gameCanvasContainer.addEventListener('mouseleave', () => { 
            if(isDragging){ 
                isDragging = false; document.body.classList.remove('is-dragging');
                gameCanvasContainer.style.cursor = 'grab';
            }
        });
        
        function centerViewOnPlayer(context = "unknown") { 
            const containerRect = gameCanvasContainer.getBoundingClientRect();
            const containerHeight = containerRect.height;
            const containerWidth = containerRect.width;
            
            if (!selfPlayer || !charSizeEstimatedAtLeastOnce || GRID_WIDTH === 0 || GRID_HEIGHT === 0 || 
                containerHeight <= 0 || containerWidth <=0 || 
                charRenderWidth <=0 || charRenderHeight <=0 || 
                gameCanvas.width === 0 || gameCanvas.height === 0) { 
                 console.warn(`[centerViewOnPlayer context: ${context}] PRECONDITIONS NOT MET.`);
                 currentPanX = 0; currentPanY = 0; updateGameTransform();
                return; 
            }
            const playerVisualCenterX_unscaled = (selfPlayer.x * charRenderWidth) + (charRenderWidth / 2);
            const playerVisualCenterY_unscaled = (selfPlayer.y * charRenderHeight) + (charRenderHeight / 2);
            
            currentPanX = (containerWidth / 2) - (playerVisualCenterX_unscaled * currentGameZoomFactor);
            currentPanY = (containerHeight / 2) - (playerVisualCenterY_unscaled * currentGameZoomFactor);
            
            gameCanvas.style.transition = 'transform 0.3s ease-out'; // Apply ease for centering
            updateGameTransform();
            setTimeout(() => { gameCanvas.style.transition = 'transform 0.05s linear'; }, 300); // Faster transition for regular updates
        }

        // --- Zoom to Mouse Logic ---
        gameCanvasContainer.addEventListener('wheel', function(event) {
            event.preventDefault();
            const rect = gameCanvasContainer.getBoundingClientRect();
            // Mouse position relative to the container (and thus, the canvas origin if no padding)
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            // Convert mouse position to world coordinates BEFORE zoom
            const worldXBeforeZoom = (mouseX - currentPanX) / currentGameZoomFactor;
            const worldYBeforeZoom = (mouseY - currentPanY) / currentGameZoomFactor;

            const delta = Math.sign(event.deltaY);
            let newZoom = currentGameZoomFactor;
            if (delta < 0) { 
                newZoom = Math.min(MAX_ZOOM, currentGameZoomFactor * (1 + ZOOM_INCREMENT * 2)); // Faster zoom increments
            } else { 
                newZoom = Math.max(MIN_ZOOM, currentGameZoomFactor / (1 + ZOOM_INCREMENT * 2));
            }
            
            if (newZoom !== currentGameZoomFactor) {
                currentGameZoomFactor = newZoom;
                
                // Calculate new pan to keep the point under the mouse stationary
                currentPanX = mouseX - (worldXBeforeZoom * currentGameZoomFactor);
                currentPanY = mouseY - (worldYBeforeZoom * currentGameZoomFactor);
                
                gameCanvas.style.transition = 'none'; // No transition during active zoom scroll
                updateGameTransform(); // Apply new zoom and pan
            }
        }, { passive: false });

        // Pinch to Zoom
        let initialPinchDistance = null;
        let lastZoomFactorOnPinchStart = currentGameZoomFactor;
        let pinchCenter = null; // To store the initial center of the pinch

        gameCanvasContainer.addEventListener('touchstart', function(event) {
            if (event.touches.length === 2) {
                event.preventDefault(); 
                const t1 = event.touches[0];
                const t2 = event.touches[1];
                initialPinchDistance = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
                lastZoomFactorOnPinchStart = currentGameZoomFactor;
                
                // Calculate initial pinch center relative to canvas container
                const rect = gameCanvasContainer.getBoundingClientRect();
                pinchCenter = {
                    x: ((t1.clientX + t2.clientX) / 2) - rect.left,
                    y: ((t1.clientY + t2.clientY) / 2) - rect.top
                };
                gameCanvas.style.transition = 'none';
            }
        }, { passive: false });

        gameCanvasContainer.addEventListener('touchmove', function(event) {
            if (event.touches.length === 2 && initialPinchDistance !== null && pinchCenter !== null) {
                event.preventDefault();
                const t1 = event.touches[0];
                const t2 = event.touches[1];
                const currentPinchDistance = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
                
                if (initialPinchDistance > 0) { 
                    const zoomRatio = currentPinchDistance / initialPinchDistance;
                    let newZoom = lastZoomFactorOnPinchStart * zoomRatio;
                    newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));
                    
                    if (newZoom !== currentGameZoomFactor) {
                        // Calculate world coords of the pinch center BEFORE zoom change
                        const worldXAtPinch = (pinchCenter.x - currentPanX) / currentGameZoomFactor;
                        const worldYAtPinch = (pinchCenter.y - currentPanY) / currentGameZoomFactor;
                        
                        currentGameZoomFactor = newZoom; // Apply new zoom
                        
                        // Adjust pan to keep the pinch center stationary
                        currentPanX = pinchCenter.x - (worldXAtPinch * currentGameZoomFactor);
                        currentPanY = pinchCenter.y - (worldYAtPinch * currentGameZoomFactor);

                        updateGameTransform();
                    }
                }
            }
        }, { passive: false });

        gameCanvasContainer.addEventListener('touchend', function(event) {
            if (event.touches.length < 2) {
                initialPinchDistance = null; 
                pinchCenter = null;
                // Re-enable smooth transition for pan if needed, though pan might also be 'none' during drag
                // if (!isDragging) gameCanvas.style.transition = 'transform 0.3s ease-out';
            }
        });


        debugInfoToggle.addEventListener('change', (event) => { 
            showDebugInfoState = event.target.checked; 
            localStorage.setItem('showDebugInfo', JSON.stringify(showDebugInfoState)); 
            debugAndAuxiliaryPanel.style.display = showDebugInfoState ? 'block' : 'none'; 
            if (!showDebugInfoState) { 
                simulateHeartbeatToggle.checked = false;
                simulateHeartbeatToggle.dispatchEvent(new Event('change')); 
            }
            updateStatus(); 
        });
        rainIntensitySlider.addEventListener('input', (event) => { /* ... (Same) ... */ });
        simulateHeartbeatToggle.addEventListener('change', (event) => { /* ... (Same, but uses showDebugInfoState now if needed) ... */ });
        const resizeObserver = new ResizeObserver(entries => { /* ... (Same, uses showDebugInfoState for welcome message) ... */ });
        if (gameCanvasContainer) resizeObserver.observe(gameCanvasContainer);

        socket.on('connect', () => { /* ... (Same) ... */ });
        socket.on('connect_error', (err) => { /* ... (Same) ... */ });
        socket.on('initial_game_data', (data) => { 
            console.log(">>> CLIENT: Received 'initial_game_data' event. Raw data:", JSON.stringify(data)); 
            if (!data || !data.player_data /* ... rest of checks ... */) { /* ... error handling ... */ return; }
            console.log("CLIENT: Processing valid 'initial_game_data'. Assigning selfPlayer...");
            selfPlayer = data.player_data; myPlayerID = selfPlayer.id; 
            console.log("CLIENT: selfPlayer assigned:", JSON.stringify(selfPlayer));
            GRID_WIDTH = data.grid_width; GRID_HEIGHT = data.grid_height; 
            GAME_HEARTBEAT_RATE = data.tick_rate || 0.75; 
            console.log(`CLIENT: Grid dimensions set to ${GRID_WIDTH}x${GRID_HEIGHT}. Heartbeat rate: ${GAME_HEARTBEAT_RATE}`);
            otherPlayers = {}; visibleTerrain = { walls: [], water: [] }; 
            visibleNPCs = data.visible_npcs || []; 
            globalWeather.intensity = data.default_rain_intensity || 0.25; 
            rainIntensitySlider.value = globalWeather.intensity;
            if (data.other_players_in_scene) { data.other_players_in_scene.forEach(p => { if (p.id !== myPlayerID) otherPlayers[p.id] = p; });}
            prevSelfPlayerState = { ...selfPlayer };
            
            const savedDebugInfo = localStorage.getItem('showDebugInfo'); 
            showDebugInfoState = savedDebugInfo !== null ? JSON.parse(savedDebugInfo) : true; 
            debugInfoToggle.checked = showDebugInfoState; 
            debugAndAuxiliaryPanel.style.display = showDebugInfoState ? 'block' : 'none';
            
            const savedSimulateHeartbeat = localStorage.getItem('simulateServerHeartbeat'); 
            if (showDebugInfoState && savedSimulateHeartbeat !== null) { 
                simulateHeartbeatToggle.checked = JSON.parse(savedSimulateHeartbeat);
            } else if (showDebugInfoState) { 
                 simulateHeartbeatToggle.checked = true; // Default sim to ON if debug is on
            }
            simulateHeartbeatToggle.dispatchEvent(new Event('change')); 
            
            console.log("CLIENT: Initializing character size estimation...");
            if (!charSizeEstimatedAtLeastOnce) { estimateCharacterSize("initial_data_pre_font_ready"); }

            document.fonts.ready.then(() => {
                console.log("CLIENT: Fonts ready. Processing initial_game_data further.");
                estimateCharacterSize("initial_data_fonts_ready"); 
                if (selfPlayer) {
                    console.log("CLIENT: selfPlayer exists. Calling drawGrid and updateStatus.");
                    drawGrid(); updateStatus(); 
                    if (gameCanvasContainer.clientHeight > 0 && !initialCenteringDone) {
                        console.log("CLIENT: Container has height. Attempting initial centering.");
                        centerViewOnPlayer("initial_data_direct_center_attempt");
                        initialCenteringDone = true;
                        if(!initialUIDone){
                             updateWeatherEffects(); 
                             logRandomizedEvent('LORE', 'WELCOME_INITIAL', {}, 'welcome-message');
                             if(showDebugInfoState) { /* Only show detailed welcome if debug is on */
                                logRandomizedEvent('LORE', 'WELCOME', { playerId: myPlayerID }, 'welcome-message');
                             }
                             if (currentSceneData.InsideID === 0 && globalWeather.isRaining) logRandomizedEvent('LORE', 'INITIAL_RAIN', {}, 'system');
                             initialUIDone = true;
                             console.log("CLIENT: Initial UI and centering complete.");
                        }
                    } else if (gameCanvasContainer.clientHeight <= 0 && !initialCenteringDone) { /* ... (timeout logic) ... */ }
                     else if (initialCenteringDone && !initialUIDone) { /* ... (UI done logic) ... */ }
                } else { /* ... (error handling) ... */ }
            }).catch(err => { /* ... (font error handling) ... */ });
            console.log("CLIENT: Finished 'initial_game_data' handler.");
        });
        socket.on('player_entered_your_scene', (newPlayerData) => { /* ... (Same) ... */ });
        socket.on('player_exited_your_scene', (exitedPlayerData) => { /* ... (Same) ... */ });
        socket.on('lore_message', (data) => { /* ... (Same) ... */ });
        socket.on('chat_message', (data) => { /* ... (Same) ... */ });
        socket.on('player_event', (data) => { /* ... (Same) ... */ });
        
        socket.on('game_update', (data) => { 
             if (!selfPlayer || !myPlayerID || !data.self_player_data) { return; }
            if(dbgLastUpdate) dbgLastUpdate.textContent = new Date().toLocaleTimeString();
            if(serverHeartbeatIndicator && !simulateServerHeartbeatEnabled) { 
                serverHeartbeatIndicator.classList.add('heartbeat-flash'); 
                if(serverHeartbeatFlashTimeout) clearTimeout(serverHeartbeatFlashTimeout); 
                serverHeartbeatFlashTimeout = setTimeout(() => { if(serverHeartbeatIndicator) serverHeartbeatIndicator.classList.remove('heartbeat-flash'); }, 150); 
            }
            const oldX = selfPlayer.x; const oldY = selfPlayer.y; const oldChar = selfPlayer.char;
            selfPlayer = data.self_player_data; 
            otherPlayers = {}; 
            if(data.visible_other_players) data.visible_other_players.forEach(p => { if (p.id !== myPlayerID) otherPlayers[p.id] = p; }); 
            visibleTerrain = data.visible_terrain || { walls: [], water: [] }; 
            visibleNPCs = data.visible_npcs || []; 
            updateStatus(); 
            if(showDebugInfoState && dbgSelfPlayer) { 
                dbgSelfPlayer.textContent = `(${selfPlayer.x},${selfPlayer.y}) ${selfPlayer.char} Wet: ${selfPlayer.is_wet}`;
                dbgOtherPlayersCount.textContent = Object.keys(otherPlayers).length;
                dbgNpcsCount.textContent = visibleNPCs.length;
            }
            const sceneChanged = prevSelfPlayerState && (selfPlayer.scene_x !== prevSelfPlayerState.scene_x || selfPlayer.scene_y !== prevSelfPlayerState.scene_y);
            const positionChanged = selfPlayer.x !== oldX || selfPlayer.y !== oldY;
            const facingChanged = selfPlayer.char !== oldChar;

            if (sceneChanged) { /* Server handles lore message for scene change */ }
            else if (positionChanged) { logRandomizedEvent('PLAYER_MOVE', null, {x: selfPlayer.x, y: selfPlayer.y, direction: getDirectionWord(selfPlayer.char)}, 'lore');}
            else if (facingChanged) { logRandomizedEvent('PLAYER_TURN', null, {direction: getDirectionWord(selfPlayer.char), x: selfPlayer.x, y: selfPlayer.y}, 'lore');}
            
            if (sceneChanged || positionChanged || facingChanged) {
                 if (!isDragging) {
                    if(!charSizeEstimatedAtLeastOnce || charRenderWidth <= 0 || charRenderHeight <= 0 || gameCanvas.width === 0){
                        estimateCharacterSize("game_update_pre_recenter_estimate"); 
                    }
                    // For zoom-to-mouse, we don't auto-center on player move/turn unless zoom is also changing
                    // centerViewOnPlayer("game_update_recentering"); // Re-evaluate if this is desired
                }
            }
            prevSelfPlayerState = { ...selfPlayer }; 
            drawGrid(); 
            if (!charSizeEstimatedAtLeastOnce && GRID_WIDTH > 0 && GRID_HEIGHT > 0) { 
                 estimateCharacterSize("game_update_reestimate"); 
                 if(!isDragging) centerViewOnPlayer("game_update_after_reestimate_centering");
            }
            updateWeatherEffects(); 
        });
        function getDirectionWord(char) { 
            if (char === '^') return "North"; if (char === 'v') return "South";
            if (char === '<') return "West";  if (char === '>') return "East";
            return "an unknown direction";
        }
        socket.on('action_feedback', (data) => { /* ... (Same - key logic already corrected) ... */ });
        socket.on('disconnect', (reason) => { /* ... (Same) ... */ });
        
        const ACTION_ALIASES = { /* ... (Same) ... */ };
        const DIRECTION_ALIASES = { /* ... (Same) ... */ };
        function parseAction(actionWord) { /* ... (Same) ... */ }
        function parseDirection(directionStr, curFacing) { /* ... (Same) ... */ }
        commandInput.addEventListener('keydown', (event) => { /* ... (Same) ... */ });
        
        commandForm.addEventListener('submit', (event) => { /* ... (Same - look command logic was already updated for client-side) ... */ });

        window.toggleRainDebug = function() { /* ... (Same) ... */ };
        window.toggleInsideDebug = function() { /* ... (Same) ... */ };
        
        // Initial setup
        initializeTheme(); 
        updateGameZoomCSS();
        estimateCharacterSize("initial_page_load"); 
        
        debugInfoToggle.checked = showDebugInfoState; 
        debugAndAuxiliaryPanel.style.display = showDebugInfoState ? 'flex' : 'none';
        
        const savedSimulateHeartbeat = localStorage.getItem('simulateServerHeartbeat'); 
        if (showDebugInfoState && savedSimulateHeartbeat !== null) { 
            simulateHeartbeatToggle.checked = JSON.parse(savedSimulateHeartbeat);
        } else if (showDebugInfoState) { 
             simulateHeartbeatToggle.checked = true; // Default sim to ON if debug is on
        }
        simulateHeartbeatToggle.dispatchEvent(new Event('change')); 

        drawGrid(); 
        if (commandInput) { commandInput.focus(); }
        updateStatus("Awaiting connection to the Ethereal Plane..."); 
        updateWeatherEffects(); 
        logRandomizedEvent('LORE', 'WELCOME_INITIAL', {}, 'welcome-message');

    </script>
</body>
</html>