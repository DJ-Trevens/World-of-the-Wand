<!DOCTYPE html>
<html lang = "en">
<head>
    <meta charset = "UTF-8">
    <meta name = "viewport" content = "width = device-width, initial-scale = 1.0">
    <title>World of the Wand - Tome of Echoes</title>
    <link rel = "stylesheet" href = "{{url_for('game.static', filename = 'style.css')}}">

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
        const socket = io({path: "/world-of-the-wand/socket.io"});
    </script>
</head>
<body>
    <div class="main-ui-container">
        <div class="left-panel">
            <div id="commandLog"></div>
        </div>

        <div class="right-panel">
            <div id="mainHeaderStatusContainer">
                <div id="debugMenu">
                    <label>
                        <input type="checkbox" id="debugInfoToggle"> Debug Info
                    </label>
                    <label>
                        <input type="checkbox" id="localCommandsToggle" checked> Local Commands
                    </label>
                    <div id="rainIntensityControl">
                        <label>
                            Rain Intensity: <input type="range" id="rainIntensitySlider" min="0" max="1" step="0.05">
                        </label>
                    </div>
                </div>
                <div id="mainHeaderStatus">Welcome to the World of the Wand!</div>
            </div>

            <div id="gameCanvasContainer">
                <div id="gameCanvas">Initializing Realm...</div>
                <div id="rainOverlay"></div>
            </div>
            
            <div id="commandInputBox">
                <form id="commandForm">
                    <label for="commandText">
                        <span id="tickIndicator">●</span>Inscribe Thy Will:
                    </label>
                    <div id="commandText" contenteditable="true" spellcheck="false" autocomplete="off" role="textbox" aria-multiline="false"></div>
                    <button type="submit">Commit</button>
                </form>
            </div>
        </div>
    </div>

    <script>
        const gameCanvas = document.getElementById('gameCanvas');
        const gameCanvasContainer = document.getElementById('gameCanvasContainer');
        const rainOverlay = document.getElementById('rainOverlay');
        const mainHeaderStatus = document.getElementById('mainHeaderStatus');
        const commandLog = document.getElementById('commandLog');
        const commandForm = document.getElementById('commandForm');
        const commandInput = document.getElementById('commandText');
        const tickIndicator = document.getElementById('tickIndicator');
        const debugInfoToggle = document.getElementById('debugInfoToggle');
        const localCommandsToggle = document.getElementById('localCommandsToggle');
        const rainIntensitySlider = document.getElementById('rainIntensitySlider');
        const rainIntensityControl = document.getElementById('rainIntensityControl');

        let showDebugInfo = false; 
        let useLocalCommands = true; 
        
        let selfPlayer = null;
        let otherPlayers = {}; 
        let myPlayerID = null; 
        let GRID_WIDTH = 20; 
        let GRID_HEIGHT = 15;
        let GAME_TICK_RATE = 0.75;
        let OBSERVABLE_DEPTH = 17;
        let prevSelfPlayerState = null;

        let currentSceneData = { 
            InsideID: 0, 
            name: "The Whispering Plains" 
        };
        let globalWeather = {
            isRaining: true, 
            intensity: 0.1 
        };
        let rainInterval = null;
        const RAIN_INTERVAL_DELAY = 50; 

        let isDragging = false;
        let startDragX, startDragY;
        let currentPanX = 0, currentPanY = 0; 
        let targetPanX = 0, targetPanY = 0;   

        let charRenderWidth = 10; 
        let charRenderHeight = 16; 
        let charSizeEstimated = false;

        const FOG_CHAR = '░'; 
        const FLOOR_CHAR = '·'; 
        const AURA_VISION_RANGE = 1;

        function get_dx_dy_from_direction_str(s) { /* ... unchanged ... */ }
        function get_direction_str_from_dx_dy(dx, dy) { /* ... unchanged ... */ }
        function getRelativeCoords(playerX, playerY, playerFacingChar, targetX, targetY) { /* ... unchanged ... */ }
        function manhattanDistance(x1, y1, x2, y2) { /* ... unchanged ... */ }
        function isVisible(observerX, observerY, observerChar, targetX, targetY, scry = false) { /* ... unchanged ... */ }
        function addLogMessage(message, type = 'lore') { /* ... unchanged ... */ }
        function updateStatus(statusText) { /* ... unchanged ... */ }
        function estimateCharacterSize(context = "unknown") { /* ... unchanged ... */ }
        function drawGrid() { /* ... unchanged ... */ }
        function startRainEffect(intensity) { /* ... unchanged ... */ }
        function stopRainEffect() { /* ... unchanged ... */ }
        function updateWeatherEffects() { /* ... unchanged ... */ }
        gameCanvasContainer.addEventListener('mousedown', (e) => { /* ... unchanged ... */ });
        window.addEventListener('mousemove', (e) => { /* ... unchanged ... */ });
        window.addEventListener('mouseup', (e) => { /* ... unchanged ... */ });
        gameCanvasContainer.addEventListener('mouseleave', () => { /* ... unchanged ... */ });
        function centerViewOnPlayer() { /* ... unchanged ... */ }
        debugInfoToggle.addEventListener('change', (event) => { /* ... unchanged ... */ });
        localCommandsToggle.addEventListener('change', (event) => { /* ... unchanged ... */ });
        rainIntensitySlider.addEventListener('input', (event) => { /* ... unchanged ... */ });
        socket.on('connect', () => { /* ... unchanged ... */ });
        socket.on('connect_error', (err) => { /* ... unchanged ... */ });
        socket.on('initial_game_data', (data) => { /* ... unchanged ... */ });
        socket.on('player_entered_your_scene', (newPlayerData) => { /* ... unchanged ... */ });
        socket.on('player_exited_your_scene', (exitedPlayerData) => { /* ... unchanged ... */ });
        socket.on('lore_message', (data) => { /* ... unchanged ... */ });
        socket.on('chat_message', (data) => { /* ... unchanged ... */ });
        let tickFlashTimeout = null;
        socket.on('game_update', (data) => { /* ... unchanged ... */ });
        function getDirectionWord(char) { /* ... unchanged ... */ }
        socket.on('action_feedback', (data) => { /* ... unchanged ... */ });
        socket.on('disconnect', (reason) => { /* ... unchanged ... */ });

        const ACTION_ALIASES = {
            "move": ["move", "go", "walk", "step", "head", "run"],
            "look": ["look", "face", "turn"],
            "cast": ["cast", "zap", "fire", "spell"],
            "drink": ["drink", "quaff", "use"],
            "say": ["say", "tell", "whisper", "'"], 
            "shout": ["shout", "yell", "scream", "!"], 
            "help": ["help", "?"] // Corrected typo here
        };
        const DIRECTION_ALIASES = { /* ... unchanged ... */ };

        function parseAction(actionWord) {
            console.log("[parseAction] Input actionWord:", `'${actionWord}'`); // Log input
            actionWord = actionWord.toLowerCase();
            for (const canonicalAction in ACTION_ALIASES) {
                // console.log("[parseAction] Checking canonical:", canonicalAction, "with aliases:", ACTION_ALIASES[canonicalAction]); // Verbose
                if (ACTION_ALIASES[canonicalAction].includes(actionWord)) {
                    console.log("[parseAction] Found canonical:", canonicalAction);
                    return canonicalAction;
                }
            }
            console.log("[parseAction] No canonical action found for:", actionWord);
            return null;
        }
        function parseDirection(directionStr, curFacing) { /* ... unchanged ... */ }

        commandInput.addEventListener('keydown', (event) => { /* ... unchanged ... */ });

        commandForm.addEventListener('submit', (event) => {
            event.preventDefault();
            if (!selfPlayer) {
                addLogMessage("Tome whispers urgently: You are not fully manifest in this realm yet!", 'event-bad');
                return;
            }
            const inputText = commandInput.textContent.trim();
            commandInput.innerHTML = ''; 

            if (!inputText) return;
            
            const parts = inputText.split(/\s+/);
            let actionWord = parts[0];
            let messageContent = parts.length > 1 ? parts.slice(1).join(' ') : null;

            console.log(`[Submit] inputText: '${inputText}', actionWord: '${actionWord}', messageContent: '${messageContent}'`);


            if (actionWord.startsWith("'") && actionWord.length >=1) { 
                messageContent = (actionWord.substring(1) + (messageContent ? " " + messageContent : "")).trim();
                actionWord = "say";
            } else if (actionWord.startsWith("!") && actionWord.length >=1) { 
                 messageContent = (actionWord.substring(1) + (messageContent ? " " + messageContent : "")).trim();
                actionWord = "shout";
            }
            addLogMessage(`Tome jots down: ${actionWord}${messageContent ? ' ' + messageContent : ''}`, 'user-input');
            
            // Log ACTION_ALIASES to ensure it's what we expect just before parsing
            console.log("[Submit] ACTION_ALIASES before parseAction:", JSON.stringify(ACTION_ALIASES));

            const canonicalAction = parseAction(actionWord);
            console.log(`[Submit] canonicalAction from parseAction: '${canonicalAction}'`);


            if (!canonicalAction) {
                addLogMessage(`Tome seems puzzled: Your will "${actionWord}" is indecipherable. (Perhaps 'help' will illuminate the path?)`, 'event-bad');
                commandInput.focus(); return;
            }

            let commandToSend = { type: canonicalAction, details: {} };
            let shouldEmitToServer = true; 
            // Temporarily disable local commands to simplify debugging server-side logic first
            // useLocalCommands = false; 

            if (useLocalCommands && (canonicalAction === "move" || canonicalAction === "look")) {
                shouldEmitToServer = false; 
                const effectiveTargetWord = messageContent || (canonicalAction === "move" ? "forward" : selfPlayer.char); 
                console.log(`[Submit - Local] canonicalAction: ${canonicalAction}, effectiveTargetWord: ${effectiveTargetWord}`);
                const dirResult = parseDirection(effectiveTargetWord, selfPlayer.char);
                console.log(`[Submit - Local] dirResult:`, dirResult);

                if (dirResult.isValid) {
                    let newX = selfPlayer.x;
                    let newY = selfPlayer.y;

                    if (canonicalAction === "move") {
                        newX += dirResult.dx;
                        newY += dirResult.dy;
                        newX = Math.max(0, Math.min(GRID_WIDTH - 1, newX));
                        newY = Math.max(0, Math.min(GRID_HEIGHT - 1, newY));
                    }
                    
                    selfPlayer.x = newX;
                    selfPlayer.y = newY;
                    selfPlayer.char = dirResult.char; 
                    
                    addLogMessage(`Tome (Local): You ${canonicalAction} ${getDirectionWord(dirResult.char)}.`, 'system');
                    drawGrid();
                    if (!isDragging) requestAnimationFrame(() => setTimeout(() => centerViewOnPlayer(), 0));
                    updateStatus();
                } else {
                    addLogMessage(`Tome frowns (Local): Your path to "${effectiveTargetWord}" is unclear.`, 'event-bad');
                }
            } else if (canonicalAction === "move") { 
                const effectiveTargetWord = messageContent || "forward"; 
                const dirResult = parseDirection(effectiveTargetWord, selfPlayer.char);
                if (dirResult.isValid) {
                    commandToSend.details = { dx: dirResult.dx, dy: dirResult.dy, newChar: dirResult.char };
                } else { 
                    addLogMessage(`Tome frowns: You ponder moving towards "${effectiveTargetWord}", but the way is unclear.`, 'event-bad');
                    shouldEmitToServer = false;
                }
            } else if (canonicalAction === "look") { 
                const effectiveTargetWord = messageContent || selfPlayer.char; 
                const dirResult = parseDirection(effectiveTargetWord, selfPlayer.char);
                if (dirResult.isValid) {
                    commandToSend.details = { dx: 0, dy: 0, newChar: dirResult.char }; 
                } else { 
                    addLogMessage(`Tome squints: You try to peer towards "${effectiveTargetWord}", but your vision blurs.`, 'event-bad');
                    shouldEmitToServer = false;
                }
            } else if (canonicalAction === "help") { 
                addLogMessage("Tome patiently explains:\nMOVE: 'move [direction]' (n,s,e,w,fwd,back)\nLOOK: 'look [direction]'\nCAST: 'cast [spell] [direction]'\nDRINK: 'drink potion'\nSAY: 'say [message]' or '[message] (quote first)\nSHOUT: 'shout [message]' or ![message] (exclamation first)", 'system');
                shouldEmitToServer = false; 
            } else if (canonicalAction === "cast") { 
                 if (messageContent) {
                    commandToSend.details = { spellName: messageContent.split(' ')[0], targetDirection: messageContent.split(' ').length > 1 ? messageContent.split(' ')[1] : null }; 
                 } else { 
                    addLogMessage(`Tome asks: Cast what, O Wizard?`, 'event-bad');
                    shouldEmitToServer = false;
                 }
            } else if (canonicalAction === "drink") {
                if (messageContent && !(messageContent.toLowerCase().includes("potion"))) {
                    addLogMessage(`Tome queries: Drink what specifically? (Try 'drink potion')`, 'event-bad');
                    shouldEmitToServer = false; 
                } else {
                    commandToSend.type = 'drink_potion'; 
                }
            } else if (canonicalAction === "say" || canonicalAction === "shout") {
                if (messageContent && messageContent.length > 0) {
                    commandToSend.details = { message: messageContent };
                } else { 
                    addLogMessage(`Tome asks: ${canonicalAction.charAt(0).toUpperCase() + canonicalAction.slice(1)} what, O Wizard?`, 'event-bad');
                    shouldEmitToServer = false;
                }
            }
            else { 
                addLogMessage(`Tome sighs: The arcane art of "${canonicalAction}" is unknown.`, 'event-bad');
                shouldEmitToServer = false;
            }

            if (shouldEmitToServer) {
                console.log("Emitting 'queue_player_action':", commandToSend);
                socket.emit('queue_player_action', commandToSend);
            }
            commandInput.focus();
        });
        
        window.toggleRainDebug = function() { /* ... unchanged ... */ };
        window.toggleInsideDebug = function() { /* ... unchanged ... */ };
        gameCanvas.textContent = "Initializing Realm...";
        if (commandInput) { commandInput.focus(); }
        // Load preferences (omitted for brevity)
        updateStatus("Awaiting connection to the Ethereal Plane..."); 
        updateWeatherEffects(); 
        addLogMessage("Tome unfurls its pages: Welcome, Wizard. The Ethereal Waves await your command.", 'welcome-message');

    </script>
</body>
</html>