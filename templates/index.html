<!DOCTYPE html>
<html lang = "en">
<head>
    <meta charset = "UTF-8">
    <meta name = "viewport" content = "width = device-width, initial-scale = 1.0">
    <title>World of the Wand</title>
    <link rel = "stylesheet" href = "{{url_for('game.static', filename = 'style.css')}}">
    
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
        const socket = io({path: "/world-of-the-wand/socket.io"});
    </script>
</head>
<body>
    <div id = "commandLog"></div>
    <div id = "gameCanvas"> Summoning World... </div>
    <div id = "mainHeaderstatus"> Pondering the Ethereal Wave... </div>

    <div id = "commandInputBox">
        <form id = "commandForm">
            <label for = "commandText">Your will, Wizard?</label>
            <div id = "commandText" contenteditable = "true" spellcheck = "false" autocomplete = "off" role = "textbox" aria-multiline = "false"></div>
            <button type = "submit">Commit</button>
        </form>
    </div>

    <script>
        const gameCanvas = document.getElementById('gameCanvas');
        const mainHeaderStatus = document.getElementById('mainHeaderStatus');

        const commandLog = document.getElementById('commandLog');
        const commandForm = document.getElementById('commandForm');
        const commandInput = document.getElementById('commandText');

        // -- Client-Side Game State -- //
        let selfPlayer = null;
        let otherPlayers = {};
        let myPlayerID = null;
        let GRID_WIDTH = 0;
        let GRID_HEIGHT = 0;
        let GAME_TICK_RATE = 2.0;

        // -- Fog of War -- //
        const FOG_CHAR = 'â–’';
        const FLOOR_CHAR = '.';
        const WALL_CHAR = '#';
        const OBSERVABLE_DEPTH = 7; // How many steps away you can see
        const OBSERVABLE_WIDTH = 1.0 // Cone's width increases by 1 for each step away
        const AURA_VISION_RANGE = 1; // See directly adjacent tiles

        // -- Helper functions -- //
        function get_dx_dy_from_direction_str(s) {
            const mapping = {'^': [0, -1], 'v': [0, 1], '<': [-1, 0], '>': [1, 0]};
            return mapping[s] || [0, 0];
        }

        function get_direction_str_from_dx_dy(dx, dy) {
            const mapping = {"0, -1": '^', "0, 1": 'v', "-1, 0": '<', "1, 0": '>'};
            return mapping[`${dx}, ${dy}`];
        }

        function getRelativeCoords(playerX, playerY, playerFacingChar, targetX, targetY) {
            const worldDX = targetX - playerX;
            const worldDY = targetY - playerY;

            let pf; // "player facing"
            if (playerFacingChar === '^') pf = 'n';
            else if (playerFacingChar === 'v') pf = 's';
            else if (playerFacingChar === '<') pf = 'w';
            else if (playerFacingChar === '>') pf = 'e';
            else return { rx: worldDX, ry: worldDY }; // Fallback

            if (pf === 'n') return {rx: worldDX, ry: worldDY};
            if (pf === 's') return {rx: -worldDX, ry: -worldDY};
            if (pf === 'w') return {rx: -worldDY, ry: worldDX};
            if (pf === 'e') return {rx: worldDY, ry: -worldDX};
            
            return { rx: worldDX, ry: worldDY }; // Fallback
        }

        function manhattanDistance(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) + Math.abs(y1 - y2);
        }

        function isVisible(observerX, observerY, observerChar, targetX, targetY, scry = false) {
            if (!observerChar) return false;

            // Aura Vision
            let manhattanDist = manhattanDistance(playerX, playerY, targetX, targetY)
            if (scry || manhattanDist <= AURA_VISION_RANGE) {
                return true;
            }
            const dxWorld = targetX - observerX;
            const dyWorld = targetY - observerY;

            let {rx, ry} = getRelativeCoords(playerX, playerY, playerFacingChar, targetX, targetY);
            if (manhattanDist === 2 && Math.abs(dxWorld) === 1 && Math.abs(dyWorld) === 1 & rx <= 0) {
                return true;
            }

            // Observation Cone!!! Observe! :)
            if (ry < 0 && -ry <= OBSERVABLE_DEPTH && Math.abs(rx) <= Math.floor(-ry * OBSERVABLE_WIDTH)) {
                return true;
            }

            return false; // Not in aura nor observable cone.
        }

        function addLogMessage(message, type = 'info') {
            const logEntry = document.createElement('div');
            logEntry.classList.add('log-entry');
            if (type) {
                logEntry.classList.add(`log-type-${type}`);
            }
            // Sanitize text content to prevent accidental HTML injection from messages
            logEntry.textContent = message; 
            commandLog.appendChild(logEntry);
            commandLog.scrollTop = commandLog.scrollHeight; // Auto-scroll to the latest message
        }

        function updateStatus(status) { 
            if (status) { 
                mainHeaderStatus.textContent = status; 
            } else if (selfPlayer) {
                mainHeaderStatus.textContent = "${player.char}: (${player.x}, ${player.y}) | Mana: 175/175 | Wand: 100%"; 
            } else {
                mainHeaderStatus.textContent = "Awaiting Your Manifestation...";
            }
        }

        function drawGrid() {
            // Simple grid drawing implementation
            if (!selfPlayer || GRID_WIDTH === 0 || GRID_HEIGHT === 0) {
                gameCanvas.textContent = "The mists obscure your vision... (Awaiting server data)"
                return;
            }

            let displayGrid = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(FLOOR_CHAR));
            for (const playerID in otherPlayers) {
                const otherGuy = otherPlayers[playerID];
                if (otherGuy.x >= 0 && otherGuy.x < GRID_WIDTH && otherGuy.y >= 0 && otherGuy.y < GRID_HEIGHT) {
                    displayGrid[otherGuy.y][otherGuy.x] = otherGuy.char;
                }
            }

            if (selfPlayer.x >= 0 && selfPlayer.x < GRIDWIDTH && selfPlayer.y >= 0 && selfPlayer.y < GRID_HEIGHT) {
                displayGrid[selfPlayer.y][selfPlayer.x] = selfPlayer.char;
            }

            let output = ""
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (isVisible(selfPlayer.x, selfPlayer.y, selfPlayer.char, x, y)) {
                        output += displayGrid[y][x];
                    } else {
                        output += FOG_CHAR;
                    }
                }
                output += "\n";
            }
            gameCanvas.textContent = output;
            updateStatus();
        }

        // -- WebSocket Event Handlers -- //
        socket.on('connect', () => {
            console.log('Connected to server! SID: ', socket.id);
            updateStatus("Divining your essence...");
        });

        socket.on('initial_state', (data) => {
            console.log('Recieved initial state: ', data);
            selfPlayer = data.player;
            myPlayerID = selfPlayer.id;
            GRID_WIDTH = data.grid_width;
            GRID_HEIGHT = data.grid_height;
            GAME_TICK_RATE = data.tick_rate;
            otherPlayers = data.otherPlayers || {};

            // Ensure self is not in otherPlayers list (server should prevent this)
            if (otherPlayers[myPlayerID]) delete otherPlayers[myPlayerID];

            if (selfPlayer && typeof GRID_WIDTH === 'number' && GRID_WIDTH > 0) {
                updateStatus();
                drawGrid();
                addLogMessage("You have materialized in a foreboding meadow. The world awaits your epic journey!", "server");
            } else {
                console.error("Initial state data incomplete or invalid: ", data);
                updateStatus("Error manifesting world.");
                addLogMessage("Error: Could not manifest in world.", "error");
            }
        });

        socket.on('player_joined', (newPlayer) => {
            console.log('Player joined: ', newPlayer);
            if (myPlayerID && newPlayer.id !== myPlayerID) {
                otherPlayers[newPlayer.id] = newPlayer;
                drawGrid(); //redraw to show the new player (?)
                addLogMessage("You sense the arrival of another powerful sorcerer.", "game-event");
            }
        });

        socket.on('player_left', (playerID) => {
            console.log('Player left: ', playerID);
            if (otherPlayers[playerID]) {
                delete otherPlayers[playerId];
                drawGrid();
                addLogMessage("You sense a powerful sorcerer depart to another plane.", "game-event");
            }
        });

        socket.on('game_state_update', (allPlayers) => {
            // console.log('Game state update recieved', allPlayers.length, "players");
            let foundSelf = false;
            const currentOtherPlayers = {};

            for (const playerData of allplayers) {
                if (playerData.id === myPlayerID) {
                    selfPlayer = playerData;
                    foundSelf = true;
                } else {
                    currentOtherPlayers[playerData.id] = playerData;
                }
            }
            otherPlayers = currentOtherPlayers;

            if (!foundSelf && myPlayerID) {
                console.warn("Self not found in game state update. Possible desync or disconnect.");
                updateStatus("Your connection to this world wavers... (bad connection)");
                addLogMessage("Warning: Connection to self is unstable.", "error");
            }

            drawGrid();
        });

        socket.on('action_queued', (data) => {
            addLogMessage(data.message, "server");
        });

        socket.on('action_failed', (data) => {
            addLogMessage("Action failed.", "server");
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from server.');
            updateStatus("Severed from the Ethereal Plane! (Disconnected)");
            addLogMessage("Disconnected from server!", "error");
            selfPlayer = null;
            otherPlayers = {};
            drawGrid();
        });

        // -- Command Config -- //
        const ACTION_ALIASES = {
            "move":     ["move", "go", "walk", "step", "head", "run"],
            "look":     ["look", "face", "turn"],
            "cast":     ["cast", "zap", "fire", "spell"],
            "help":     ["help", "?"]
        };

        const DIRECTION_ALIASES = {
            // Cardinal Directions
            "north":    {char: '^', dx: 0,  dy: -1, aliases: ["north", "n", "up"]},
            "south":    {char: 'v', dx: 0,  dy: 1,  aliases: ["south", "s", "down"]},
            "west":     {char: '<', dx: -1, dy: 0,  aliases: ["west", "w", "left", "lft", "l"]},
            "east":    {char: '>', dx: 1,  dy: 0,  aliases: ["east", "e", "right", "rght", "rgt", "r"]},
            // Relative Directions
            "forward":  {relative: true, aliases: ["forward", "forwards", "fwd", "f", "ahead", "straight", "onward", "onwards"]},
            "backward": {relative: true, aliases: ["backward", "backwards", "back", "bck", "behind", "b"]},
        }

        // -- Command Parsing -- //
        function parseAction(actionWord) {
            actionWord = actionWord.toLowerCase();
            for (const canonicalAction in ACTION_ALIASES) {
                if (ACTION_ALIASES[canonicalAction].includes(actionWord)) {
                    return canonicalAction;
                }
            }
            return null;
        }

        function parseDirection(directionStr, curFacing) {
            directionStr = directionStr.toLowerCase();
            let result = {char: curFacing, dx: 0, dy: 0, isValid: false};

            for (const dirKey in DIRECTION_ALIASES) {
                const config = DIRECTION_ALIASES[dirKey];
                if (config.aliases.includes(directionStr)) {
                    if (config.relative) {
                        result.isValid = true;
                        if          (dirKey === "forward") {
                            result.char = curFacing;
                            if      (curFacing === '^') result.dy = -1;
                            else if (curFacing === 'v') result.dy = 1;
                            else if (curFacing === '<') result.dx = -1;
                            else if (curFacing === '>') result.dx = 1;
                            else result.isValid = false;
                        } else if   (dirKey === "backward") {
                            if      (curFacing === '^') result = {char: 'v', dx: 0,  dy: 1,  isValid: true};
                            else if (curFacing === 'v') result = {char: '^', dx: 0,  dy: -1, isValid: true};
                            else if (curFacing === '<') result = {char: '>', dx: 1,  dy: 0,  isValid: true};
                            else if (curFacing === '>') result = {char: '<', dx: -1, dy: 0,  isValid: true};
                            else result.isValid = false;
                        }
                    } else {
                        result = {char: config.char, dx: config.dx, dy: config.dy, isValid: true};
                    }
                    return result; // Match found!
                }
            }
            return result;
        }

        let savedCharOffset = 0; 

        function escapeHtml(unsafe) {
            return unsafe
                 .replace(/&/g, "&")
                 .replace(/</g, "<")
                 .replace(/>/g, ">")
             //  .replace(/"/g, """)
                 .replace(/'/g, "'");
        }

        function saveCursorPosition() {
            const selection = window.getSelection();
            if (selection.rangeCount > 0 && commandInput.contains(selection.anchorNode)) {
                const range = selection.getRangeAt(0);
                const preSelectionRange = range.cloneRange();
                preSelectionRange.selectNodeContents(commandInput);
                preSelectionRange.setEnd(range.startContainer, range.startOffset);
                savedCharOffset = preSelectionRange.toString().length;
                // console.log("Saved offset:", savedCharOffset, "Current text:", commandInput.textContent);
            } else {
                savedCharOffset = (commandInput.textContent || "").length;
            }
        }

        function restoreCursorPosition() {
            commandInput.focus(); 
            const selection = window.getSelection();
            const range = document.createRange();
            let charCount = 0;
            let currentNode = null;
            let nodeCharIndex = 0;

            function findNodeAndOffsetRecursive(parentNode, targetOffset) {
                for (let i = 0; i < parentNode.childNodes.length; i++) {
                    const child = parentNode.childNodes[i];
                    if (child.nodeType === Node.TEXT_NODE) {
                        const nextCharCount = charCount + child.length;
                        if (nextCharCount >= targetOffset) {
                            currentNode = child;
                            nodeCharIndex = targetOffset - charCount;
                            return true; // Found
                        }
                        charCount = nextCharCount;
                    } else if (child.nodeType === Node.ELEMENT_NODE) {
                        // If it's an element (like our span), recurse into it
                        if (findNodeAndOffsetRecursive(child, targetOffset)) {
                            return true; // Found in child
                        }
                        // If not found in child, and the element itself contributes to the visual text length
                        // (e.g. if spans had padding or borders that affect visual position)
                        // this part could get more complex. For simple text content, recursing is enough.
                    }
                }
                return false; // Not found in this branch
            }
            
            if (findNodeAndOffsetRecursive(commandInput, savedCharOffset)) {
                try {
                    range.setStart(currentNode, nodeCharIndex);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                } catch (e) {
                    // console.warn("Error setting range, fallback to end:", e);
                    // Fallback for safety
                    range.selectNodeContents(commandInput);
                    range.collapse(false);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            } else {
                // Fallback: If exact offset not found (e.g. offset > text length), place at end
                range.selectNodeContents(commandInput);
                range.collapse(false); 
                selection.removeAllRanges();
                selection.addRange(range);
            }
        }
        
        function handleCommandInputHighlighting() {
            // Don't save/restore if we're about to clear the input on submit
            if (commandInput.getAttribute('data-clearing') === 'true') return;

            saveCursorPosition(); 

            const rawText = commandInput.textContent || ""; // Get raw text for processing
            // If the last char is a space and it's not being represented in innerHTML properly,
            // we might need special handling.
            const endsWithSpace = rawText.endsWith(' ');


            const words = rawText.split(/(\s+)/); 
            let newHtml = "";

            words.forEach((word, index) => {
                if (word.match(/^\s+$/)) { 
                    newHtml += word; // Preserve spaces as they are
                    return;
                }
                if (word === "") return; 

                let isAlias = false;
                const lowerWord = word.toLowerCase();
                // Determine if it's the first "semantic" word
                let isFirstSemanticWord = true;
                for(let i=0; i<index; i++){
                    if(words[i].trim() !== ""){
                        isFirstSemanticWord = false;
                        break;
                    }
                }


                if (isFirstSemanticWord) { 
                    for (const canonicalAction in ACTION_ALIASES) {
                        if (ACTION_ALIASES[canonicalAction].includes(lowerWord)) {
                            isAlias = true;
                            break;
                        }
                    }
                } else { 
                    for (const dirKey in DIRECTION_ALIASES) {
                        if (DIRECTION_ALIASES[dirKey].aliases.includes(lowerWord)) {
                            isAlias = true;
                            break;
                        }
                    }
                }

                if (isAlias) {
                    newHtml += `<span class="highlight-alias">${escapeHtml(word)}</span>`;
                } else {
                    newHtml += escapeHtml(word);
                }
            });

            // If the raw text ended with a space, but newHtml doesn't (e.g. if space was part of a word that got wrapped)
            // ensure the space is there. This is a bit of a heuristic.
            // A better way might be to ensure that split keeps all trailing spaces correctly.
            // The current split(/(\s+)/) should be okay.
            // The main problem is that innerHTML might collapse trailing spaces within the div itself
            // if not styled properly or if the space is the only content.
            // One trick is to add a zero-width space or   if it's just a space causing issues.
            // For now, let's trust the newHtml construction.

            if (commandInput.innerHTML !== newHtml) {
                 commandInput.innerHTML = newHtml;
            }

            restoreCursorPosition();
        }

        commandInput.addEventListener('input', handleCommandInputHighlighting);

        commandInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault(); 
                // Temporarily mark that we are clearing, so 'input' event from clear doesn't run highlight
                commandInput.setAttribute('data-clearing', 'true');
                const submitButton = commandForm.querySelector('button[type="submit"]');
                if (submitButton) submitButton.click();
                // Allow a microtask for the click/submit to process before removing the attribute
                Promise.resolve().then(() => commandInput.removeAttribute('data-clearing'));
            }
            // No need to call saveCursorPosition here, 'input' event will handle it.
        });

        //todo: implement click targeting
        //todo: implement dropdown box action selector
        commandForm.addEventListener('submit', (event) => {
            console.log("Input form submitted!");
            event.preventDefault();
            if (!selfPlayer) {
                addLogMessage("You are not fully manifest in this realm yet.", "error");
                return;
            }
            const inputText = commandInput.textContent.trim(); // Keep original case for now, parsing functions handle lowercasing
            commandInput.innerHTML = ''; // Clear input (after getting text)

            if (!inputText) return;

            addLogMessage(`> ${inputText}`); // Log the command itself

            const parts = inputText.split(/\s+/);
            const actionWord = parts[0];
            const targetWord = parts.length > 1 ? parts.slice(1).join(' ') : null;

            const canonicalAction = parseAction(actionWord);

            if (!canonicalAction) {
                addLogMessage(`Your will "${actionWord}" is indecipherable. (Type "help" for guidance - eventually!)`, "error");
                commandInput.focus();
                return;
            }
            
            let commandToSend = { type: canonicalAction, details: {} };
            let shouldEmit = false;
            
            if (canonicalAction === "move") {
                const effectiveTargetWord = targetWord || "forward";
                const dirResult = parseDirection(effectiveTargetWord, selfPlayer.char);
                if (dirResult.isValid) {
                    commandToSend.details = { dx: dirResult.dx, dy: dirResult.dy, new_char: dirResult.char };
                    shouldEmit = true;
                } else {
                    addLogMessage(`You ponder moving towards "${effectiveTargetWord}", but the way is unclear.`, "error");
                }
            } else if (canonicalAction === "look") {
                if (!targetWord) {
                    const dirResult = parseDirection("forward", selfPlayer.char);
                    commandToSend.details = { dx: 0, dy: 0, new_char: dirResult.char };
                    shouldEmit = true;
                } else {
                    const dirResult = parseDirection(targetWord, selfPlayer.char);
                    if (dirResult.isValid) {
                        commandToSend.details = { dx: 0, dy: 0, new_char: dirResult.char };
                        shouldEmit = true;
                    } else {
                        addLogMessage(`You try to peer towards "${targetWord}", but your vision blurs.`, "error");
                    }
                }
            } else {
                addLogMessage(`The arcane art of "${canonicalAction}" is yet beyond your grasp.`, "error");
            }

            if (shouldEmit) {
                socket.emit('queue_command', commandToSend);
            }
            commandInput.focus();
        });

        // Initial setup
        drawGrid();
        if (commandInput) commandInput.focus(); // Autofocus the command input div
        addLogMessage("Welcome, Wizard. The Ethereal Waves await your command.", "server");

    </script>
</body>
</html>